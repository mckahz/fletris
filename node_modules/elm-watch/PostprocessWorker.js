// src/PostprocessWorker.ts
var path = require("path");
var Codec4 = require("tiny-decoders");
var url = require("url");
var import_worker_threads = require("worker_threads");

// src/Helpers.ts
var Codec = require("tiny-decoders");
function unknownErrorToString(error) {
  return typeof error?.stack === "string" ? error.stack : typeof error?.message === "string" ? error.message : Codec.repr(error);
}

// src/NonEmptyArray.ts
var Codec2 = require("tiny-decoders");
function isNonEmptyArray(array2) {
  return array2.length >= 1;
}

// src/PostprocessShared.ts
var ELM_WATCH_NODE = "elm-watch-node";

// src/Types.ts
var Codec3 = require("tiny-decoders");
function brand() {
  return Codec3.string;
}
var AbsolutePath = brand();
var CompilationMode = Codec3.primitiveUnion([
  "debug",
  "standard",
  "optimize"
]);
var BrowserUiPosition = Codec3.primitiveUnion([
  "TopLeft",
  "TopRight",
  "BottomLeft",
  "BottomRight"
]);
var TargetName = brand();
function markAsElmWatchNodeScriptPath(string3) {
  return string3;
}
var WebSocketToken = brand();

// src/PostprocessWorker.ts
var emptyStdio = {
  stdout: "",
  stderr: ""
};
function main(port) {
  port.on("messageerror", (error) => {
    throw error;
  });
  port.on("message", (message) => {
    switch (message.tag) {
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      case "StartPostprocess":
        elmWatchNode(message.args).then((result) => {
          port.postMessage({
            tag: "PostprocessDone",
            result: { tag: "Resolve", value: result }
          });
        }).catch((error) => {
          port.postMessage({
            tag: "PostprocessDone",
            result: { tag: "Reject", error }
          });
        });
        break;
    }
  });
}
async function elmWatchNode({
  cwd,
  code,
  targetName,
  compilationMode,
  runMode,
  userArgs
}) {
  if (!isNonEmptyArray(userArgs)) {
    return { tag: "ElmWatchNodeMissingScript" };
  }
  const scriptPath = markAsElmWatchNodeScriptPath(
    url.pathToFileURL(path.resolve(cwd, userArgs[0])).toString()
  );
  let imported;
  try {
    imported = await import(scriptPath);
  } catch (unknownError) {
    return {
      tag: "ElmWatchNodeImportError",
      scriptPath,
      error: unknownValueAsString(unknownError, importErrorToString),
      ...emptyStdio
    };
  }
  if (typeof imported["default"] !== "function") {
    return {
      tag: "ElmWatchNodeDefaultExportNotFunction",
      scriptPath,
      imported: unknownValueAsString(
        // To/from entries is needed. Otherwise `repr` prints `"Module"`.
        Object.fromEntries(Object.entries(imported)),
        (value) => Codec4.repr(value, { maxObjectChildren: 10 })
      ),
      typeofDefault: typeof imported["default"],
      ...emptyStdio
    };
  }
  const args = {
    code,
    targetName,
    compilationMode,
    runMode,
    // Mimic `process.argv`: ["node", "/absolute/path/to/script", "arg1", "arg2", "..."].
    argv: [ELM_WATCH_NODE, url.fileURLToPath(scriptPath), ...userArgs.slice(1)]
  };
  let returnValue;
  try {
    returnValue = await imported["default"](args);
  } catch (unknownError) {
    return {
      tag: "ElmWatchNodeRunError",
      scriptPath,
      args,
      error: unknownValueAsString(unknownError, unknownErrorToString),
      ...emptyStdio
    };
  }
  if (typeof returnValue !== "string") {
    return {
      tag: "ElmWatchNodeBadReturnValue",
      scriptPath,
      args,
      returnValue: unknownValueAsString(returnValue, Codec4.repr),
      ...emptyStdio
    };
  }
  return { tag: "Success", code: returnValue };
}
function unknownValueAsString(value, toString) {
  return {
    tag: "UnknownValueAsString",
    value: toString(value)
  };
}
function importErrorToString(error) {
  const code = error?.code;
  return code === "ERR_MODULE_NOT_FOUND" ? error.message : unknownErrorToString(error);
}
if (import_worker_threads.parentPort === null) {
  throw new Error("PostprocessWorker.ts: worker_threads.parentPort is null!");
}
main(import_worker_threads.parentPort);
