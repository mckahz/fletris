#!/usr/bin/env node
"use strict";
// src/Compile.ts
var fs5 = require("fs");
var Codec13 = require("tiny-decoders");

// src/ElmJson.ts
var Codec5 = require("tiny-decoders");

// src/NonEmptyArray.ts
var Codec = require("tiny-decoders");
function NonEmptyArray(decoder) {
  return Codec.flatMap(Codec.array(decoder), {
    decoder: (array4) => isNonEmptyArray(array4) ? { tag: "Valid", value: array4 } : {
      tag: "DecoderError",
      error: {
        tag: "custom",
        message: "Expected a non-empty array",
        got: array4,
        path: []
      }
    },
    encoder: (array4) => array4
  });
}
function isNonEmptyArray(array4) {
  return array4.length >= 1;
}
function mapNonEmptyArray(array4, f) {
  return array4.map(f);
}
function flattenNonEmptyArray(array4) {
  return array4.flat();
}
function nonEmptyArrayUniqueBy(f, items) {
  const result = [items[0]];
  for (const item of items) {
    if (result.every((otherItem) => f(otherItem) !== f(item))) {
      result.push(item);
    }
  }
  return result;
}

// src/PathHelpers.ts
var fs = require("fs");
var path = require("path");
var Codec4 = require("tiny-decoders");

// src/Helpers.ts
var Codec2 = require("tiny-decoders");
function split(string9, splitter) {
  return string9.split(splitter);
}
function getSetSingleton(set) {
  return set.size === 1 ? Array.from(set)[0] : void 0;
}
var CLEAR = "\x1B[2J\x1B[3J\x1B[H";
var RESET_COLOR = "\x1B[0m";
function bold(string9) {
  return `${RESET_COLOR}\x1B[1m${string9}${RESET_COLOR}`;
}
function dim(string9) {
  return `${RESET_COLOR}\x1B[2m${string9}${RESET_COLOR}`;
}
function removeColor(string9) {
  return string9.replace(/\x1B\[\d+m/g, "");
}
function cursorHorizontalAbsolute(n) {
  return `\x1B[${n}G`;
}
function pad(number5) {
  return number5.toString().padStart(2, "0");
}
function quote(string9) {
  return Codec2.JSON.stringify(Codec2.string, string9);
}
function formatTime(date) {
  return [
    pad(date.getHours()),
    pad(date.getMinutes()),
    pad(date.getSeconds())
  ].join(":");
}
var KiB = 1024;
var MiB = 1048576;
function printFileSize(fileSize) {
  const [divided, unit] = fileSize >= MiB ? [fileSize / MiB, "MiB"] : [fileSize / KiB, "KiB"];
  const string9 = toFixed(divided).padStart(4, " ");
  return `${string9} ${unit}`;
}
var SECOND = 1e3;
function printDurationMs(durationMs) {
  const divided = durationMs / SECOND;
  const [string9, unit] = durationMs < SECOND ? [durationMs.toString(), "ms"] : [toFixed(divided), "s"];
  return `${string9} ${unit}`.padStart(6, " ");
}
function toFixed(n) {
  const s1 = n.toFixed(2);
  if (s1.length <= 4) {
    return s1;
  }
  const s2 = n.toFixed(1);
  if (s2.length <= 4) {
    return s2;
  }
  return n.toFixed(0);
}
function capitalize(string9) {
  return string9.slice(0, 1).toUpperCase() + string9.slice(1);
}
function silentlyReadIntEnvValue(value, defaultValue) {
  return /^\d+$/.test(value ?? "") ? Number(value) : defaultValue;
}
var toError = (arg) => (
  /* v8 ignore start */
  arg instanceof Error ? arg : new Error(
    `Caught error not instanceof Error: ${unknownErrorToString(arg)}`
  )
);
function unknownErrorToString(error) {
  return typeof error?.stack === "string" ? error.stack : typeof error?.message === "string" ? error.message : Codec2.repr(error);
}

// src/Types.ts
var Codec3 = require("tiny-decoders");
function brand() {
  return Codec3.string;
}
var AbsolutePath = brand();
function markAsAbsolutePath(string9) {
  return string9;
}
function markAsCwd(absolutePath) {
  return absolutePath;
}
var CompilationMode = Codec3.primitiveUnion([
  "debug",
  "standard",
  "optimize"
]);
var BrowserUiPosition = Codec3.primitiveUnion([
  "TopLeft",
  "TopRight",
  "BottomLeft",
  "BottomRight"
]);
function markAsElmWatchJsonPath(absolutePath) {
  return absolutePath;
}
function markAsElmJsonPath(absolutePath) {
  return absolutePath;
}
function markAsElmWatchStuffDir(absolutePath) {
  return absolutePath;
}
function markAsElmWatchStuffJsonPath(absolutePath) {
  return absolutePath;
}
function markAsSourceDirectory(absolutePath) {
  return absolutePath;
}
var TargetName = brand();
function markAsTargetName(string9) {
  return string9;
}
function markAsCliArg(string9) {
  return string9;
}
function equalsInputPath(elmFile, inputPath) {
  return inputPath.theInputPath === elmFile || inputPath.realpath === elmFile;
}
var WebSocketToken = brand();
function markAsWebSocketToken(string9) {
  return string9;
}

// src/PathHelpers.ts
function absolutePathFromString(from, ...pathStrings) {
  return markAsAbsolutePath(path.resolve(from, ...pathStrings));
}
function absoluteDirname(absolutePath) {
  return markAsAbsolutePath(path.dirname(absolutePath));
}
function absoluteRealpath(absolutePath) {
  return markAsAbsolutePath(fs.realpathSync(absolutePath));
}
function findClosest(name, absoluteDir) {
  const entry = path.join(absoluteDir, name);
  return fs.existsSync(entry) ? markAsAbsolutePath(entry) : absoluteDir === path.parse(absoluteDir).root ? void 0 : findClosest(name, absoluteDirname(absoluteDir));
}
function readJsonFile(file, codec) {
  let content;
  try {
    content = fs.readFileSync(file, "utf8");
  } catch (error) {
    return { tag: "ReadError", error: toError(error) };
  }
  return Codec4.JSON.parse(codec, content);
}

// src/ElmJson.ts
var ElmJson = Codec5.taggedUnion("type", [
  {
    type: Codec5.tag("application"),
    "source-directories": NonEmptyArray(Codec5.string)
  },
  {
    type: Codec5.tag("package")
  }
]);
function readSourceDirectories(elmJsonPath) {
  const parsed = readJsonFile(elmJsonPath, ElmJson);
  switch (parsed.tag) {
    case "DecoderError":
      return {
        tag: "ElmJsonDecodeError",
        elmJsonPath,
        error: parsed.error
      };
    case "ReadError":
      return {
        tag: "ElmJsonReadError",
        elmJsonPath,
        error: parsed.error
      };
    case "Valid":
      return {
        tag: "Parsed",
        sourceDirectories: getSourceDirectories(elmJsonPath, parsed.value)
      };
  }
}
function getSourceDirectories(elmJsonPath, elmJson2) {
  const base = absoluteDirname(elmJsonPath);
  switch (elmJson2.type) {
    case "application":
      return mapNonEmptyArray(
        elmJson2["source-directories"],
        (dir) => markAsSourceDirectory(absolutePathFromString(base, dir))
      );
    case "package":
      return [markAsSourceDirectory(absolutePathFromString(base, "src"))];
  }
}

// src/EmojiRegex.ts
/* @license

MIT License

Copyright (c) 2024 Steven Levithan

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
var r = String.raw;
var seq = r`(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation})`;
var sTags = r`\u{E0061}-\u{E007A}`;
var STARTS_WITH_EMOJI_REGEX = new RegExp(
  r`^(?:[\u{1F1E6}-\u{1F1FF}]{2}|\u{1F3F4}[${sTags}]{2}[\u{E0030}-\u{E0039}${sTags}]{1,3}\u{E007F}|${seq}(?:\u200D${seq})*) `,
  "u"
);

// src/Env.ts
var NO_COLOR = "NO_COLOR";
var ELM_WATCH_OPEN_EDITOR = "ELM_WATCH_OPEN_EDITOR";
var ELM_WATCH_EXIT_ON_STDIN_END = "ELM_WATCH_EXIT_ON_STDIN_END";
var __ELM_WATCH_OPEN_EDITOR_TIMEOUT_MS = "__ELM_WATCH_OPEN_EDITOR_TIMEOUT_MS";
var __ELM_WATCH_DEBUG = "__ELM_WATCH_DEBUG";
var __ELM_WATCH_NOT_TTY = "__ELM_WATCH_NOT_TTY";
var WT_SESSION = "WT_SESSION";
var __ELM_WATCH_MOCKED_TIMINGS = "__ELM_WATCH_MOCKED_TIMINGS";
var __ELM_WATCH_EXIT_ON_ERROR = "__ELM_WATCH_EXIT_ON_ERROR";
var __ELM_WATCH_LOADING_MESSAGE_DELAY = "__ELM_WATCH_LOADING_MESSAGE_DELAY";
var __ELM_WATCH_WORKER_LIMIT_TIMEOUT_MS = "__ELM_WATCH_WORKER_LIMIT_TIMEOUT_MS";
var __ELM_WATCH_EXIT_ON_WORKER_LIMIT = "__ELM_WATCH_EXIT_ON_WORKER_LIMIT";
var __ELM_WATCH_MAX_PARALLEL = "__ELM_WATCH_MAX_PARALLEL";
var __ELM_WATCH_TMP_DIR = "__ELM_WATCH_TMP_DIR";
var __ELM_WATCH_ELM_TIMEOUT_MS = "__ELM_WATCH_ELM_TIMEOUT_MS";
var __ELM_WATCH_QUERY_TERMINAL_TIMEOUT_MS = "__ELM_WATCH_QUERY_TERMINAL_TIMEOUT_MS";
var __ELM_WATCH_QUERY_TERMINAL_MAX_AGE_MS = "__ELM_WATCH_QUERY_TERMINAL_MAX_AGE_MS";

// src/Errors.ts
var crypto = require("crypto");
var fs2 = require("fs");
var path3 = require("path");
var Codec8 = require("tiny-decoders");
var url = require("url");

// src/ElmWatchJson.ts
var path2 = require("path");
var Codec7 = require("tiny-decoders");

// src/IsWindows.ts
var os = require("os");
var IS_WINDOWS = os.platform() === "win32";

// src/Port.ts
var Codec6 = require("tiny-decoders");
function markAsPort(number5) {
  return number5;
}
var Port = Codec6.flatMap(Codec6.number, {
  decoder: (number5) => {
    const min = 1;
    const max = 65535;
    return Number.isInteger(number5) && min <= number5 && number5 <= max ? {
      tag: "Valid",
      value: markAsPort(number5)
    } : {
      tag: "DecoderError",
      error: {
        tag: "custom",
        message: `Expected an integer where ${min} <= port <= ${max}`,
        got: number5,
        path: []
      }
    };
  },
  encoder: (port) => port
});

// src/ElmWatchJson.ts
var INPUT_NAME = /(^|[/\\])\p{Lu}[_\d\p{L}]*\.elm$/u;
function isValidInputName(name) {
  return INPUT_NAME.test(name);
}
function isValidOutputName(name) {
  return !name.startsWith("-") && name.endsWith(".js") && name !== ".js";
}
var TARGET_NAME = /^[^\s-](?:.*\S)?$/;
function isValidTargetName(name) {
  return TARGET_NAME.test(name);
}
var Target = Codec7.fields(
  {
    inputs: NonEmptyArray(
      Codec7.flatMap(Codec7.string, {
        decoder: (string9) => isValidInputName(string9) ? { tag: "Valid", value: string9 } : {
          tag: "DecoderError",
          error: {
            tag: "custom",
            message: "Inputs must have a valid module name and end with .elm",
            got: string9,
            path: []
          }
        },
        encoder: (value) => value
      })
    ),
    output: Codec7.flatMap(Codec7.string, {
      decoder: (output) => isValidOutputName(output) ? { tag: "Valid", value: output } : {
        tag: "DecoderError",
        error: {
          tag: "custom",
          message: "Outputs must end with .js",
          got: output,
          path: []
        }
      },
      encoder: (value) => value
    })
  },
  { allowExtraFields: false }
);
var TargetRecordHelper = {
  decoder: (record3) => {
    const keys = Object.keys(record3);
    for (const key of keys) {
      if (!isValidTargetName(key)) {
        return {
          tag: "DecoderError",
          error: {
            tag: "custom",
            message: "Target names must start with a non-whitespace character except `-`,\ncannot contain newlines and must end with a non-whitespace character",
            got: key,
            path: [key]
          }
        };
      }
    }
    return isNonEmptyArray(keys) ? { tag: "Valid", value: record3 } : {
      tag: "DecoderError",
      error: {
        tag: "custom",
        message: "Expected a non-empty object",
        got: record3,
        path: []
      }
    };
  },
  encoder: (value) => value
};
var Config = Codec7.fields(
  {
    targets: Codec7.flatMap(Codec7.record(Target), TargetRecordHelper),
    postprocess: Codec7.field(NonEmptyArray(Codec7.string), { optional: true }),
    port: Codec7.field(Port, { optional: true })
  },
  { allowExtraFields: false }
);
function findReadAndParse(cwd) {
  const elmWatchJsonPathRaw = findClosest("elm-watch.json", cwd);
  if (elmWatchJsonPathRaw === void 0) {
    return {
      tag: "ElmWatchJsonNotFound"
    };
  }
  const elmWatchJsonPath = markAsElmWatchJsonPath(elmWatchJsonPathRaw);
  const parsed = readJsonFile(elmWatchJsonPathRaw, Config);
  switch (parsed.tag) {
    case "DecoderError":
      return {
        tag: "DecoderError",
        elmWatchJsonPath,
        error: parsed.error
      };
    case "ReadError":
      return {
        tag: "ReadError",
        elmWatchJsonPath,
        error: parsed.error
      };
    case "Valid":
      return {
        tag: "Parsed",
        elmWatchJsonPath,
        config: parsed.value
      };
  }
}
function example(cwd, elmWatchJsonPath, elmMakeParsed) {
  const { elmFiles, output = "build/main.js" } = elmMakeParsed;
  const json2 = {
    targets: {
      "My target name": {
        inputs: isNonEmptyArray(elmFiles) ? mapNonEmptyArray(
          elmFiles,
          (file) => (
            // Use slashes in all paths since they work everywhere (including
            // Windows), while backslashes only work on Windows.
            toUnixPath(
              path2.relative(
                path2.dirname(elmWatchJsonPath),
                path2.resolve(cwd, file)
              )
            )
          )
        ) : ["src/Main.elm"],
        output
      }
    }
  };
  return Codec7.JSON.stringify(Config, json2, 4);
}
function toUnixPath(filePath) {
  return IS_WINDOWS ? filePath.split(path2.sep).join(path2.posix.sep) : filePath;
}
function parseArgsLikeElmMake(args) {
  return args.reduce(
    (passedParsed, arg) => {
      const parsed = { ...passedParsed, justSawOutputFlag: false };
      switch (arg) {
        case "--debug":
        case "--optimize":
          return parsed;
        case "--output":
          return { ...parsed, justSawOutputFlag: true };
        default: {
          if (passedParsed.justSawOutputFlag) {
            return isValidOutputName(arg) ? { ...parsed, output: arg } : parsed;
          }
          const outputPrefix = "--output=";
          if (arg.startsWith(outputPrefix)) {
            const file = arg.slice(outputPrefix.length);
            return isValidOutputName(file) ? { ...parsed, output: file } : parsed;
          }
          return isValidInputName(arg) ? { ...parsed, elmFiles: parsed.elmFiles.concat(arg) } : parsed;
        }
      }
    },
    {
      elmFiles: [],
      output: void 0,
      justSawOutputFlag: false
    }
  );
}

// src/Logger.ts
var readline = require("readline");
var util = require("util");
var DEFAULT_COLUMNS = 80;
function makeLogger({
  env,
  getNow,
  stdin,
  stdout,
  stderr,
  logDebug
}) {
  const noColor = NO_COLOR in env;
  const handleColor = (string9) => noColor ? removeColor(string9) : string9;
  let queryTerminalStatus = { tag: "NotQueried" };
  const defaultOnExit = () => {
  };
  let onExit = defaultOnExit;
  const exitOnCtrlC = (data) => {
    if (data.toString("utf8") === "") {
      onExit();
    }
  };
  const exitOnStdinEnd = () => {
    onExit();
  };
  const queryTerminalTimeoutMs = silentlyReadIntEnvValue(
    env[__ELM_WATCH_QUERY_TERMINAL_TIMEOUT_MS],
    100
  );
  const queryTerminalMaxAgeMs = silentlyReadIntEnvValue(
    env[__ELM_WATCH_QUERY_TERMINAL_MAX_AGE_MS],
    1e3
  );
  const config = {
    debug: __ELM_WATCH_DEBUG in env,
    noColor,
    fancy: (
      /* v8 ignore next */
      (!IS_WINDOWS || WT_SESSION in env) && !noColor
    ),
    isTTY: __ELM_WATCH_NOT_TTY in env ? (
      /* v8 ignore next */
      false
    ) : stdout.isTTY,
    mockedTimings: __ELM_WATCH_MOCKED_TIMINGS in env,
    get columns() {
      return stdout.columns ?? DEFAULT_COLUMNS;
    }
  };
  if (ELM_WATCH_EXIT_ON_STDIN_END in env) {
    stdin.on("end", exitOnStdinEnd);
    stdin.resume();
  }
  return {
    write(message) {
      stdout.write(`${handleColor(message)}
`);
    },
    writeToStderrMakesALotOfSenseHere(message) {
      stderr.write(`${handleColor(message)}
`);
    },
    errorTemplate(template2) {
      stdout.write(
        `${toTerminalString(template2, config.columns, noColor)}
`
      );
    },
    /* v8 ignore start */
    debug(...args) {
      if (config.debug) {
        logDebug(
          args.map(
            (arg, index) => index === 0 && typeof arg === "string" && !noColor ? bold(arg) : util.inspect(arg, {
              depth: Infinity,
              colors: !noColor,
              maxStringLength: 1e3
            })
          ).join("\n")
        );
      }
    },
    /* v8 ignore stop */
    clearScreen() {
      if (config.isTTY) {
        stdout.write(CLEAR);
      }
    },
    clearScreenDown() {
      if (config.isTTY) {
        readline.clearScreenDown(stdout);
      }
    },
    clearLine(dir) {
      if (config.isTTY) {
        readline.clearLine(stdout, dir);
      }
    },
    moveCursor(dx, dy) {
      if (config.isTTY) {
        readline.moveCursor(stdout, dx, dy);
      }
    },
    setRawMode(passedOnExit) {
      onExit = passedOnExit;
      if (stdin.isTTY && stdout.isTTY && !stdin.isRaw) {
        stdin.setRawMode(true);
        stdin.on("data", exitOnCtrlC);
        stdin.resume();
      }
    },
    reset() {
      onExit = defaultOnExit;
      queryTerminalStatus = { tag: "NotQueried" };
      stdin.pause();
      stdin.off("data", exitOnCtrlC);
      stdin.off("end", exitOnStdinEnd);
      if (stdin.isRaw) {
        stdin.setRawMode(false);
      }
    },
    async queryTerminal(escapes, isDone) {
      if (!stdin.isRaw) {
        return void 0;
      }
      const run4 = async () => {
        const callbacks = [];
        queryTerminalStatus = { tag: "Querying", callbacks };
        const result = await queryTerminalHelper(
          queryTerminalTimeoutMs,
          stdin,
          stdout,
          escapes,
          isDone
        );
        queryTerminalStatus = {
          tag: "Queried",
          stdin: result,
          date: getNow()
        };
        for (const callback of callbacks) {
          callback(result);
        }
        return result;
      };
      switch (queryTerminalStatus.tag) {
        case "NotQueried":
          return run4();
        case "Querying": {
          const { callbacks } = queryTerminalStatus;
          return new Promise((resolve3) => {
            callbacks.push(resolve3);
          });
        }
        case "Queried":
          return getNow().getTime() - queryTerminalStatus.date.getTime() <= queryTerminalMaxAgeMs ? queryTerminalStatus.stdin : run4();
      }
    },
    config
  };
}
async function queryTerminalHelper(queryTerminalTimeoutMs, stdin, stdout, escapes, isDone) {
  return new Promise((resolve3) => {
    let stdinString = "";
    const onStdin = (data) => {
      stdinString += data.toString("utf8");
      if (isDone(stdinString)) {
        clearTimeout(timeoutId);
        stdin.off("data", onStdin);
        resolve3(stdinString);
      }
    };
    stdin.on("data", onStdin);
    stdout.write(escapes);
    const timeoutId = setTimeout(() => {
      stdin.off("data", onStdin);
      resolve3(void 0);
    }, queryTerminalTimeoutMs);
  });
}

// src/PostprocessShared.ts
var ELM_WATCH_NODE = "elm-watch-node";

// src/Theme.ts
var THEME_ESCAPES_STRING = Array.from(
  { length: 16 },
  (_, i) => `\x1B]4;${i};?\x1B\\`
  // Palette.
).concat("\x1B]10;?\x1B\\", "\x1B]11;?\x1B\\").join("");
var THEME_ESCAPES_DONE_CHECK = "]11;";
var THEME_ESCAPES_REGEX = /\x1B](4;)?(\d+);rgb:([\da-f]{4})\/([\da-f]{4})\/([\da-f]{4})/gi;
var INDEX_TO_COLOR = {
  0: "black",
  1: "red",
  2: "green",
  3: "yellow",
  4: "blue",
  5: "magenta",
  6: "cyan",
  7: "white",
  8: "BLACK",
  9: "RED",
  10: "GREEN",
  11: "YELLOW",
  12: "BLUE",
  13: "MAGENTA",
  14: "CYAN",
  15: "WHITE"
};
var COLOR_TO_TERMINAL_ESCAPE = {
  red: "\x1B[31m",
  RED: "\x1B[91m",
  magenta: "\x1B[35m",
  MAGENTA: "\x1B[95m",
  yellow: "\x1B[33m",
  YELLOW: "\x1B[93m",
  green: "\x1B[32m",
  GREEN: "\x1B[92m",
  cyan: "\x1B[36m",
  CYAN: "\x1B[96m",
  blue: "\x1B[34m",
  BLUE: "\x1B[94m",
  black: "\x1B[30m",
  BLACK: "\x1B[90m",
  white: "\x1B[37m",
  WHITE: "\x1B[97m"
};
var DEFAULT_THEME = {
  // Picked using eye dropper on VSCode’s default dark theme, in its terminal.
  foreground: "rgb(204, 204, 204)",
  background: "rgb(32, 30, 30)",
  // Taken from the “Visual Studio Code” column at:
  // https://en.wikipedia.org/wiki/ANSI_escape_code#Colors
  palette: {
    red: "rgb(205, 49, 49)",
    RED: "rgb(241, 76, 76)",
    magenta: "rgb(188, 63, 188)",
    MAGENTA: "rgb(214, 112, 214)",
    yellow: "rgb(229, 229, 16)",
    YELLOW: "rgb(245, 245, 67)",
    green: "rgb(13, 188, 121)",
    GREEN: "rgb(35, 209, 139)",
    cyan: "rgb(17, 168, 205)",
    CYAN: "rgb(41, 184, 219)",
    blue: "rgb(36, 114, 200)",
    BLUE: "rgb(59, 142, 234)",
    black: "rgb(0, 0, 0)",
    BLACK: "rgb(102, 102, 102)",
    white: "rgb(229, 229, 229)",
    WHITE: "rgb(229, 229, 229)"
  }
};
async function getThemeFromTerminal(logger) {
  if (IS_WINDOWS) {
    return DEFAULT_THEME;
  }
  const stdin = await logger.queryTerminal(
    THEME_ESCAPES_STRING,
    (stdinSoFar) => stdinSoFar.includes(THEME_ESCAPES_DONE_CHECK)
  );
  return stdin === void 0 ? DEFAULT_THEME : parseTheme(stdin);
}
function parseTheme(stdin) {
  const theme = { ...DEFAULT_THEME, palette: { ...DEFAULT_THEME.palette } };
  for (const match of stdin.matchAll(THEME_ESCAPES_REGEX)) {
    const [, isPaletteString, indexString, r2 = "0", g = "0", b = "0"] = match;
    const isPalette = isPaletteString !== void 0;
    const index = Number(indexString);
    const color = `#${convert(r2)}${convert(g)}${convert(b)}`;
    if (isPalette) {
      const colorName = INDEX_TO_COLOR[index];
      if (colorName !== void 0) {
        theme.palette[colorName] = color;
      }
    } else if (index === 10) {
      theme.foreground = color;
    } else if (index === 11) {
      theme.background = color;
    }
  }
  return theme;
}
function convert(hexDigits) {
  return Math.floor(parseInt(hexDigits, 16) / 65535 * 255).toString(16).padStart(2, "0");
}

// src/Errors.ts
function bold2(string9) {
  return { tag: "Bold", text: string9 };
}
function dim2(string9) {
  return { tag: "Dim", text: string9 };
}
function text(string9) {
  return { tag: "Text", text: string9.trim() };
}
function number2(num) {
  return { tag: "Text", text: num.toString() };
}
function join2(array4, separator) {
  return text(array4.join(separator));
}
function json(data, indent) {
  return {
    tag: "Text",
    text: indent === void 0 ? Codec8.JSON.stringify(Codec8.unknown, data) : Codec8.JSON.stringify(Codec8.unknown, data, indent)
  };
}
function joinTemplate(array4, separator) {
  return template(
    ["", ...Array.from({ length: array4.length - 1 }, () => separator), ""],
    ...array4
  );
}
var elmJson = bold2("elm.json");
var elmWatchJson = bold2("elm-watch.json");
var elmWatchStuffJson = bold2("elm-stuff/elm-watch/stuff.json");
var fancyError = (title, location) => (strings, ...values) => (width, renderPiece) => ({
  title,
  location: fancyToPlainErrorLocation(location),
  content: template(strings, ...values)(width, renderPiece)
});
var template = (strings, ...values) => (width, renderPiece) => strings.flatMap((string9, index) => {
  const value = values[index] ?? text("");
  return [
    string9,
    typeof value === "function" ? value(width, renderPiece) : renderPiece(value)
  ];
}).join("").trim();
function toTerminalString(errorTemplate, width, noColor) {
  const renderPiece = noColor ? (piece) => piece.text : renderPieceForTerminal;
  const { title, location, content } = errorTemplate(width, renderPiece);
  const prefix = `-- ${title} `;
  const line = "-".repeat(Math.max(0, width - prefix.length));
  const titleWithSeparator = renderPiece(bold2(`${prefix}${line}`));
  return [
    titleWithSeparator,
    ...location === void 0 ? [] : [renderPiece(renderErrorLocation(location))],
    "",
    content
  ].join("\n");
}
function toPlainString(errorTemplate) {
  return toTerminalString(errorTemplate, DEFAULT_COLUMNS, true);
}
function toHtml(errorTemplate, theme, noColor) {
  const renderPiece = (piece) => noColor ? piece.text : renderPieceToHtml(piece, theme);
  const { title, location, content } = errorTemplate(
    DEFAULT_COLUMNS,
    renderPiece
  );
  return location === void 0 ? { title, htmlContent: content } : { title, location, htmlContent: content };
}
function renderPieceForTerminal(piece) {
  switch (piece.tag) {
    case "Bold":
      return bold(piece.text);
    case "Dim":
      return dim(piece.text);
    case "ElmStyle":
      return (piece.bold ? (
        /* v8 ignore next */
        "\x1B[1m"
      ) : "") + (piece.underline ? "\x1B[4m" : "") + (piece.color === void 0 ? "" : COLOR_TO_TERMINAL_ESCAPE[piece.color]) + piece.text + RESET_COLOR;
    case "Text":
      return piece.text;
  }
}
function renderPieceToHtml(piece, theme) {
  switch (piece.tag) {
    case "Bold":
      return `<b>${escapeHtml(piece.text)}</b>`;
    case "Dim":
      return `<span style="opacity: 0.6">${escapeHtml(piece.text)}</span>`;
    case "ElmStyle":
      return (piece.bold ? (
        /* v8 ignore next */
        "<b>"
      ) : "") + (piece.underline ? "<u>" : "") + (piece.color === void 0 ? "" : `<span style="color: ${theme.palette[piece.color]}">`) + escapeHtml(piece.text) + (piece.color === void 0 ? "" : "</span>") + (piece.underline ? "</u>" : "") + (piece.bold ? (
        /* v8 ignore next */
        "</b>"
      ) : "");
    case "Text":
      return escapeHtml(piece.text);
  }
}
function escapeHtml(string9) {
  return string9.replace(/[&<>"']/g, (match) => {
    switch (match) {
      case "&":
        return "&amp;";
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case '"':
        return "&quot;";
      case "'":
        return "&apos;";
      /* v8 ignore start */
      default:
        return match;
    }
  });
}
function fancyToPlainErrorLocation(location) {
  switch (location.tag) {
    case "ElmJsonPath":
      return { tag: "FileOnly", file: location.theElmJsonPath };
    case "ElmWatchJsonPath":
      return { tag: "FileOnly", file: location.theElmWatchJsonPath };
    case "ElmWatchStuffJsonPath":
      return { tag: "FileOnly", file: location.theElmWatchStuffJsonPath };
    case "OutputPath":
      return { tag: "Target", targetName: location.targetName };
    case "ElmWatchNodeScriptPath":
      return {
        tag: "FileOnly",
        file: markAsAbsolutePath(
          url.fileURLToPath(location.theElmWatchNodeScriptPath)
        )
      };
    case "FileWithLineAndColumn":
      return location;
    case "NoLocation":
      return void 0;
  }
}
function renderErrorLocation(location) {
  switch (location.tag) {
    case "FileOnly":
      return text(location.file);
    case "FileWithLineAndColumn":
      return text(`${location.file}:${location.line}:${location.column}`);
    case "Target":
      return dim2(`Target: ${location.targetName}`);
  }
}
function readElmWatchJson(elmWatchJsonPath, error) {
  return fancyError("TROUBLE READING elm-watch.json", {
    tag: "ElmWatchJsonPath",
    theElmWatchJsonPath: elmWatchJsonPath
  })`
I read inputs, outputs and options from ${elmWatchJson}.

${bold2("I had trouble reading it:")}

${text(error.message)}
`;
}
function decodeElmWatchJson(elmWatchJsonPath, error) {
  return fancyError("INVALID elm-watch.json FORMAT", {
    tag: "ElmWatchJsonPath",
    theElmWatchJsonPath: elmWatchJsonPath
  })`
I read inputs, outputs and options from ${elmWatchJson}.

${bold2("I had trouble with the JSON inside:")}

${printJsonError(error)}
`;
}
function elmWatchJsonNotFound(cwd, args) {
  const example2 = example(
    cwd,
    markAsElmWatchJsonPath(absolutePathFromString(cwd, "elm-watch.json")),
    parseArgsLikeElmMake(args)
  );
  return fancyError("elm-watch.json NOT FOUND", { tag: "NoLocation" })`
I read inputs, outputs and options from ${elmWatchJson}.

${bold2("But I couldn't find one!")}

You need to create one with JSON like this:

${text(example2)}
`;
}
function debugOptimizeForHot() {
  const make2 = bold2("elm-watch make");
  const hot = bold2("elm-watch hot");
  return fancyError("REDUNDANT FLAGS", { tag: "NoLocation" })`
${bold2("--debug")} and ${bold2("--optimize")} only make sense for ${make2}.
When using ${hot}, you can switch mode in the browser.
`;
}
function debugOptimizeClash() {
  return fancyError("CLASHING FLAGS", { tag: "NoLocation" })`
${bold2("--debug")} and ${bold2("--optimize")} cannot be used at the same time.
`;
}
function unknownFlags(cwd, elmWatchJsonPath, runMode, args, theUnknownFlags) {
  const elmMakeParsed = parseArgsLikeElmMake(args);
  const extra = elmMakeParsed.output !== void 0 ? template`
It looks like your arguments might fit in an ${bold2("elm make")} command.
If so, you could try moving them to the ${elmWatchJson} I found here:

${text(elmWatchJsonPath)}

For example, you could add some JSON like this:

${text(example(cwd, elmWatchJsonPath, elmMakeParsed))}
  ` : text("");
  return fancyError("UNEXPECTED FLAGS", { tag: "NoLocation" })`
${printRunModeArgsHelp(runMode)}

But you provided these flag-looking args:

${join2(theUnknownFlags, "\n")}

Try removing those extra flags!

${extra}
`;
}
function printRunModeArgsHelp(runMode) {
  switch (runMode) {
    case "make":
      return template`The ${bold2(
        runMode
      )} command only accepts the flags ${bold2("--debug")} and ${bold2(
        "--optimize"
      )}.`;
    case "hot":
      return template`The ${bold2(
        runMode
      )} command only accepts no flags at all.`;
  }
}
function unknownTargetsSubstrings(elmWatchJsonPath, knownTargets, theUnknownTargetsSubstrings) {
  return fancyError("UNKNOWN TARGETS SUBSTRINGS", {
    tag: "ElmWatchJsonPath",
    theElmWatchJsonPath: elmWatchJsonPath
  })`
I read inputs, outputs and options from ${elmWatchJson}.

It contains these targets:

${join2(knownTargets, "\n")}

${bold2("But none of those match these substrings you gave me:")}

${join2(theUnknownTargetsSubstrings, "\n")}

Is something misspelled?
Or do you need to add some more targets?
`;
}
function elmJsonNotFound(outputPath, inputs, foundElmJsonPaths) {
  const extra = isNonEmptyArray(foundElmJsonPaths) ? template`
Note that I did find an ${elmJson} for some inputs:

${join2(
    mapNonEmptyArray(
      foundElmJsonPaths,
      ({ inputPath, elmJsonPath }) => `${inputPath.originalString}
-> ${elmJsonPath}`
    ),
    "\n\n"
  )}

Make sure that one single ${elmJson} covers all the inputs together!
      ` : text("");
  return fancyError("elm.json NOT FOUND", outputPath)`
I could not find an ${elmJson} for these inputs:

${join2(
    mapNonEmptyArray(inputs, (inputPath) => inputPath.originalString),
    "\n"
  )}

Has it gone missing? Maybe run ${bold2("elm init")} to create one?

${extra}
`;
}
function nonUniqueElmJsonPaths(outputPath, theNonUniqueElmJsonPaths) {
  return fancyError("NO UNIQUE elm.json", outputPath)`
I went looking for an ${elmJson} for your inputs, but I found more than one!

${join2(
    mapNonEmptyArray(
      theNonUniqueElmJsonPaths,
      ({ inputPath, elmJsonPath }) => `${inputPath.originalString}
-> ${elmJsonPath}`
    ),
    "\n\n"
  )}

It doesn't make sense to compile Elm files from different projects into one output.

Either split this target, or move the inputs to the same project with the same
${elmJson}.
`;
}
function inputsNotFound(outputPath, inputs) {
  return fancyError("INPUTS NOT FOUND", outputPath)`
You asked me to compile these inputs:

${joinTemplate(
    mapNonEmptyArray(
      inputs,
      (inputPath) => template`${text(inputPath.originalString)} ${dim2(
        `(${inputPath.theUncheckedInputPath})`
      )}`
    ),
    "\n"
  )}

${bold2("But they don't exist!")}

Is something misspelled? Or do you need to create them?
`;
}
function inputsFailedToResolve(outputPath, inputs) {
  return fancyError("INPUTS FAILED TO RESOLVE", outputPath)`
I start by checking if the inputs you give me exist,
but doing so resulted in errors!

${join2(
    mapNonEmptyArray(
      inputs,
      ({ inputPath, error }) => `${inputPath.originalString}:
${error.message}`
    ),
    "\n\n"
  )}

${bold2("That's all I know, unfortunately!")}
`;
}
function duplicateInputs(outputPath, duplicates) {
  const isSymlink = (inputPath) => inputPath.theInputPath !== inputPath.realpath;
  const hasSymlink = duplicates.some(({ inputs }) => inputs.some(isSymlink));
  const symlinkText = hasSymlink ? "Note that at least one of the inputs seems to be a symlink. They can be tricky!" : "";
  return fancyError("DUPLICATE INPUTS", outputPath)`
Some of your inputs seem to be duplicates!

${joinTemplate(
    mapNonEmptyArray(
      duplicates,
      ({ inputs, resolved }) => joinTemplate(
        [
          ...mapNonEmptyArray(
            inputs,
            (inputPath) => isSymlink(inputPath) ? template`${text(inputPath.originalString)} ${dim2("(symlink)")}` : text(inputPath.originalString)
          ),
          text(`-> ${resolved}`)
        ],
        "\n"
      )
    ),
    "\n\n"
  )}

Make sure every input is listed just once!

${text(symlinkText)}
`;
}
function duplicateOutputs(elmWatchJsonPath, duplicates) {
  return fancyError("DUPLICATE OUTPUTS", {
    tag: "ElmWatchJsonPath",
    theElmWatchJsonPath: elmWatchJsonPath
  })`
Some of your outputs seem to be duplicates!

${joinTemplate(
    mapNonEmptyArray(
      duplicates,
      ({ originalOutputPathStrings, absolutePath }) => join2([...originalOutputPathStrings, `-> ${absolutePath}`], "\n")
    ),
    "\n\n"
  )}

Make sure every output is listed just once!
`;
}
function elmNotFoundError(location, command) {
  return fancyError("ELM NOT FOUND", location)`
I tried to execute ${bold2(command.command)}, but it does not appear to exist!

${printPATH(command.options.env, IS_WINDOWS)}

Is Elm installed?

Note: If you have installed Elm locally (for example using npm or elm-tooling),
execute elm-watch using npx to make elm-watch automatically pick up that local
installation: ${bold2("npx elm-watch")}
`;
}
function commandNotFoundError(outputPath, command) {
  return fancyError("COMMAND NOT FOUND", outputPath)`
I tried to execute ${bold2(command.command)}, but it does not appear to exist!

${printPATH(command.options.env, IS_WINDOWS)}

Is ${bold2(command.command)} installed?
`;
}
function otherSpawnError(location, error, command) {
  return fancyError("TROUBLE SPAWNING COMMAND", location)`
I tried to execute ${bold2(command.command)}, but I ran into an error!

${text(error.message)}

This happened when trying to run the following commands:

${printCommand(command)}
`;
}
function unexpectedElmMakeOutput(outputPath, exitReason2, stdout, stderr, command) {
  return fancyError("UNEXPECTED ELM OUTPUT", outputPath)`
I ran the following commands:

${printCommand(command)}

I expected it to either exit 0 with no output (success),
or exit 1 with JSON on stderr (compile errors).

${bold2("But it exited like this:")}

${printExitReason(exitReason2)}
${printStdio(stdout, stderr)}
`;
}
function unexpectedElmInstallOutput(elmJsonPath, exitReason2, stdout, stderr, command) {
  return fancyError("UNEXPECTED ELM OUTPUT", {
    tag: "ElmJsonPath",
    theElmJsonPath: elmJsonPath
  })`
I tried to make sure all packages are installed by running the following commands:

${printCommand(command)}

I expected it to either exit 0 with no output (success),
or exit 1 with an error I can recognize (using regex) on stderr.

${bold2("But it exited like this:")}

${printExitReason(exitReason2)}
${printStdio(stdout, stderr)}
`;
}
function postprocessStdinWriteError(location, error, command) {
  return fancyError("POSTPROCESS STDIN TROUBLE", location)`
I tried to run your postprocess command:

${printCommand(command)}

Trying to write to its ${bold2("stdin")}, I got an error!
${bold2("Did you forget to read stdin, maybe?")}

Note: If you don't need stdin in some case, you can pipe it to stdout!

This is the error message I got:

${text(error.message)}
`;
}
function postprocessNonZeroExit(outputPath, exitReason2, stdout, stderr, command) {
  return fancyError("POSTPROCESS ERROR", outputPath)`
I ran your postprocess command:

${printCommand(command)}

${bold2("It exited with an error:")}

${printExitReason(exitReason2)}
${printStdio(stdout, stderr)}
`;
}
function elmWatchNodeMissingScript(elmWatchJsonPath) {
  return fancyError("MISSING POSTPROCESS SCRIPT", {
    tag: "ElmWatchJsonPath",
    theElmWatchJsonPath: elmWatchJsonPath
  })`
You have specified this in ${elmWatchJson}:

"postprocess": [${json(ELM_WATCH_NODE)}]

You need to specify a JavaScript file to run as well, like so:

"postprocess": [${json(ELM_WATCH_NODE)}, "postprocess.js"]
`;
}
function elmWatchNodeImportError(scriptPath, error, stdout, stderr) {
  return fancyError("POSTPROCESS IMPORT ERROR", {
    tag: "ElmWatchNodeScriptPath",
    theElmWatchNodeScriptPath: scriptPath
  })`
I tried to import your postprocess file:

${printElmWatchNodeImportCommand(scriptPath)}

But that resulted in this error:

${printUnknownValueAsString(error)}

${printElmWatchNodeStdio(stdout, stderr)}
`;
}
function elmWatchNodeDefaultExportNotFunction(scriptPath, imported, typeofDefault, stdout, stderr) {
  const moduleExports = text("module.exports");
  return fancyError("MISSING POSTPROCESS DEFAULT EXPORT", {
    tag: "ElmWatchNodeScriptPath",
    theElmWatchNodeScriptPath: scriptPath
  })`
I imported your postprocess file:

${printElmWatchNodeImportCommand(scriptPath)}

I expected ${bold2("imported.default")} to be a function, but it isn't!

typeof imported.default === ${json(typeofDefault)}

${bold2("imported")} is:

${printUnknownValueAsString(imported)}

Here is a sample function to get you started:

// CJS
${moduleExports} = async function postprocess({ code, targetName, compilationMode }) {
  return code;
};

// MJS
export default async function postprocess({ code, targetName, compilationMode }) {
  return code;
};

${printElmWatchNodeStdio(stdout, stderr)}
`;
}
function elmWatchNodeRunError(scriptPath, args, error, stdout, stderr) {
  return fancyError("POSTPROCESS RUN ERROR", {
    tag: "ElmWatchNodeScriptPath",
    theElmWatchNodeScriptPath: scriptPath
  })`
I tried to run your postprocess command:

${printElmWatchNodeImportCommand(scriptPath)}
${printElmWatchNodeRunCommand(args)}

But that resulted in this error:

${printUnknownValueAsString(error)}

${printElmWatchNodeStdio(stdout, stderr)}
`;
}
function elmWatchNodeBadReturnValue(scriptPath, args, returnValue, stdout, stderr) {
  return fancyError("INVALID POSTPROCESS RESULT", {
    tag: "ElmWatchNodeScriptPath",
    theElmWatchNodeScriptPath: scriptPath
  })`
I ran your postprocess command:

${printElmWatchNodeImportCommand(scriptPath)}
${printElmWatchNodeRunCommand(args)}

I expected ${bold2("result")} to be a string, but it is:

${printUnknownValueAsString(returnValue)}

${printElmWatchNodeStdio(stdout, stderr)}
`;
}
function printElmMakeCrashBeforeError(beforeError) {
  switch (beforeError.tag) {
    case "Json":
      return template`I got back ${number2(
        beforeError.length
      )} characters of JSON, but then Elm crashed with this error:`;
    case "Text":
      return beforeError.text === "" ? template`Elm crashed with this error:` : template`Elm printed this text:

${text(beforeError.text)}

Then it crashed with this error:`;
  }
}
function elmMakeCrashError(outputPath, beforeError, error, command) {
  return fancyError("ELM CRASHED", outputPath)`
I ran the following commands:

${printCommand(command)}

${printElmMakeCrashBeforeError(beforeError)}

${text(error)}
`;
}
function elmMakeJsonParseError(outputPath, error, errorFilePath, command) {
  return fancyError("TROUBLE WITH JSON REPORT", outputPath)`
I ran the following commands:

${printCommand(command)}

I seem to have gotten some JSON back as expected,
but I ran into an error when decoding it:

${printJsonError(error)}

${printErrorFilePath(errorFilePath)}
`;
}
function elmMakeGeneralError(outputPath, elmJsonPath, error, extraError) {
  return fancyError(
    error.title,
    generalErrorPath(outputPath, elmJsonPath, error.path)
  )`
${text(extraError ?? "")}

${joinTemplate(error.message.map(renderMessageChunk), "")}
`;
}
function generalErrorPath(outputPath, elmJsonPath, errorPath) {
  switch (errorPath) {
    case null:
      return outputPath;
    case "elm.json":
      return { tag: "ElmJsonPath", theElmJsonPath: elmJsonPath };
  }
}
function elmMakeProblem(filePath, problem, extraError) {
  return fancyError(problem.title, {
    tag: "FileWithLineAndColumn",
    file: filePath,
    line: problem.region.start.line,
    column: problem.region.start.column
  })`
${text(extraError ?? "")}

${joinTemplate(problem.message.map(renderMessageChunk), "")}
`;
}
function renderMessageChunk(chunk) {
  return typeof chunk === "string" ? (
    // This does not use `text()` since that function trims whitespace.
    { tag: "Text", text: chunk }
  ) : {
    tag: "ElmStyle",
    text: chunk.string,
    bold: chunk.bold,
    underline: chunk.underline,
    color: chunk.color ?? void 0
  };
}
function stuckInProgressState(outputPath, state) {
  return fancyError("STUCK IN PROGRESS", outputPath)`
I thought that all outputs had finished compiling, but my inner state says
this target is still in the ${bold2(state)} phase.

${bold2("This is not supposed to ever happen.")}
`;
}
function creatingDummyFailed(elmJsonPath, error) {
  return fancyError("FILE SYSTEM TROUBLE", {
    tag: "ElmJsonPath",
    theElmJsonPath: elmJsonPath
  })`
I tried to make sure that all packages are installed. To do that, I need to
create a temporary dummy .elm file but that failed:

${text(error.message)}
`;
}
function elmInstallError(elmJsonPath, title, message) {
  return fancyError(title, { tag: "ElmJsonPath", theElmJsonPath: elmJsonPath })`
${text(message)}
`;
}
function readElmJson(elmJsonPath, error) {
  return fancyError("TROUBLE READING elm.json", {
    tag: "ElmJsonPath",
    theElmJsonPath: elmJsonPath
  })`
I read "source-directories" from ${elmJson} when figuring out all Elm files that
your inputs depend on.

${bold2("I had trouble reading it:")}

${text(error.message)}

(I still managed to compile your code, but the watcher will not work properly
and "postprocess" was not run.)
`;
}
function decodeElmJson(elmJsonPath, error) {
  return fancyError("INVALID elm.json FORMAT", {
    tag: "ElmJsonPath",
    theElmJsonPath: elmJsonPath
  })`
I read "source-directories" from ${elmJson} when figuring out all Elm files that
your inputs depend on.

${bold2("I had trouble with the JSON inside:")}

${printJsonError(error)}

(I still managed to compile your code, but the watcher will not work properly
and "postprocess" was not run.)
`;
}
function readElmWatchStuffJson(elmWatchStuffJsonPath, error) {
  return fancyError("TROUBLE READING elm-stuff/elm-watch/stuff.json", {
    tag: "ElmWatchStuffJsonPath",
    theElmWatchStuffJsonPath: elmWatchStuffJsonPath
  })`
I read stuff from ${elmWatchStuffJson} to remember some things between runs.

${bold2("I had trouble reading it:")}

${text(error.message)}

This file is created by elm-watch, so reading it should never fail really.
You could try removing that file (it contains nothing essential).
`;
}
function decodeElmWatchStuffJson(elmWatchStuffJsonPath, error) {
  return fancyError("INVALID elm-stuff/elm-watch/stuff.json FORMAT", {
    tag: "ElmWatchStuffJsonPath",
    theElmWatchStuffJsonPath: elmWatchStuffJsonPath
  })`
I read stuff from ${elmWatchStuffJson} to remember some things between runs.

${bold2("I had trouble with the JSON inside:")}

${printJsonError(error)}

This file is created by elm-watch, so reading it should never fail really.
You could try removing that file (it contains nothing essential).
`;
}
function elmWatchStuffJsonWriteError(elmWatchStuffJsonPath, error) {
  return fancyError("TROUBLE WRITING elm-stuff/elm-watch/stuff.json", {
    tag: "ElmWatchStuffJsonPath",
    theElmWatchStuffJsonPath: elmWatchStuffJsonPath
  })`
I write stuff to ${elmWatchStuffJson} to remember some things between runs.

${bold2("I had trouble writing that file:")}

${text(error.message)}

The file contains nothing essential, but something weird is going on.
`;
}
function importWalkerFileSystemError(outputPath, error) {
  return fancyError("TROUBLE READING ELM FILES", outputPath)`
When figuring out all Elm files that your inputs depend on I read a lot of Elm files.
Doing so I encountered this error:

${text(error.message)}

(I still managed to compile your code, but the watcher will not work properly
and "postprocess" was not run.)
`;
}
function needsToWriteProxyFileReadError(outputPath, error, triedPath) {
  return fancyError("TROUBLE CHECKING OUTPUT", outputPath)`
I managed to typecheck your code. Then I tried to read part of the previous output,
to see if I need to write a dummy output file there:

${text(triedPath)}

Doing so I encountered this error:

${text(error.message)}
`;
}
function readOutputError(outputPath, error, triedPath) {
  return fancyError("TROUBLE READING OUTPUT", outputPath)`
I managed to compile your code. Then I tried to read the output:

${text(triedPath)}

Doing so I encountered this error:

${text(error.message)}
`;
}
function writeOutputError(outputPath, error, reasonForWriting) {
  return fancyError("TROUBLE WRITING OUTPUT", outputPath)`
I managed to compile your code and read the generated file:

${text(outputPath.temporaryOutputPath)}

${printWriteOutputErrorReasonForWriting(reasonForWriting)}

${text(outputPath.theOutputPath)}

But I encountered this error:

${text(error.message)}
`;
}
function printWriteOutputErrorReasonForWriting(reasonForWriting) {
  switch (reasonForWriting) {
    case "InjectWebSocketClient":
      return text(
        "I injected code for hot reloading, and then tried to write that to the output path:"
      );
    case "Postprocess":
      return text(
        "After running your postprocess command, I tried to write the result of that to the output path:"
      );
  }
}
function writeProxyOutputError(outputPath, error) {
  return fancyError("TROUBLE WRITING DUMMY OUTPUT", outputPath)`
There are no WebSocket connections for this target, so I only typecheck the
code. That went well. Then I tried to write a dummy output file here:

${text(outputPath.theOutputPath)}

Doing so I encountered this error:

${text(error.message)}
`;
}
function portConflictForNoPort(error) {
  return fancyError("PORT CONFLICT", { tag: "NoLocation" })`
I ask the operating system for an arbitrary available port for the
web socket server.

The operating system is supposed to always be able to find an available port,
but it looks like that wasn't the case this time!

This is the error message I got:

${text(error.message)}
  `;
}
function portConflictForPersistedPort(elmWatchStuffJsonPath, port) {
  return fancyError("PORT CONFLICT", {
    tag: "ElmWatchStuffJsonPath",
    theElmWatchStuffJsonPath: elmWatchStuffJsonPath
  })`
I ask the operating system for an arbitrary available port for the
web socket server.

I then save the port I got to ${elmWatchStuffJson}. Otherwise I would
get a new port number on each restart, which means that if you had tabs
open in the browser they would try to connect to the old port number.

I tried to use such a saved port number from a previous run (or from previous
configuration). But now that port (${number2(port)}) wasn't available!

Most likely you already have elm-watch running somewhere else! If so,
find it and use that, or kill it.

If not, something else could have started using port ${number2(port)}
(though it's not very likely.) Then you can either try to find what that is,
or remove ${elmWatchStuffJson} here:

${text(elmWatchStuffJsonPath)}

Then I will ask the operating system for a new arbitrary available port.
  `;
}
function portConflictForPortFromConfig(elmWatchJsonPath, port) {
  return fancyError("PORT CONFLICT", {
    tag: "ElmWatchJsonPath",
    theElmWatchJsonPath: elmWatchJsonPath
  })`
In your ${elmWatchJson} you have this:

"port": ${json(port)}

But something else seems to already be running on that port!
You might already have elm-watch running somewhere, or it could be a completely
different program.

You need to either find and stop that other thing, switch to another port or
remove "port" from ${elmWatchJson} (which will use an arbitrary available port.)
  `;
}
function watcherError(error) {
  return fancyError("WATCHER ERROR", { tag: "NoLocation" })`
The file watcher encountered an error, which means that it cannot continue.
elm-watch is powered by its file watcher, so I have to exit at this point.

See if this is something you can solve by maybe removing some problematic files
or something!

This is the error message I got:

${text(error.message)}
  `;
}
function webSocketBadUrl(expectedStart, actualUrlString) {
  return `
I expected the web socket connection URL to start with:

${expectedStart}

But it looks like this:

${actualUrlString}

The web socket code I generate is supposed to always connect using a correct URL, so something is up here.
  `.trim();
}
function webSocketParamsDecodeError(error, actualUrlString) {
  return `
I ran into trouble parsing the web socket connection URL parameters:

${printJsonError(error).text}

The URL looks like this:

${actualUrlString}

The web socket code I generate is supposed to always connect using a correct URL, so something is up here. Maybe the JavaScript code running in the browser was compiled with an older version of elm-watch? If so, try reloading the page.
  `;
}
function webSocketWrongToken() {
  return `
The web socket connected with the wrong security token. The security token is used to block malicious connections.

The web socket code I generate is supposed to always connect using the correct token, so something is up here. Maybe the JavaScript code running in the browser was compiled with an older version of elm-watch? If so, try reloading the page.
    `.trim();
}
function webSocketWrongVersion(expectedVersion, actualVersion) {
  return `
The compiled JavaScript code running in the browser says it was compiled with:

elm-watch ${actualVersion}

But the server is:

elm-watch ${expectedVersion}

Maybe the JavaScript code running in the browser was compiled with an older version of elm-watch? If so, try reloading the page.
  `.trim();
}
function webSocketTargetNotFound(targetName, enabledOutputs, disabledOutputs) {
  const extra = isNonEmptyArray(disabledOutputs) ? `

These targets are also available in elm-watch.json, but are not enabled (because of the CLI arguments passed):

${mapNonEmptyArray(disabledOutputs, (outputPath) => outputPath.targetName).join("\n")}
  `.trimEnd() : "";
  return `
The compiled JavaScript code running in the browser says it is for this target:

${targetName}

But I can't find that target in elm-watch.json!

These targets are available in elm-watch.json:

${enabledOutputs.map((outputPath) => outputPath.targetName).join("\n")}${extra}

Maybe this target used to exist in elm-watch.json, but you removed or changed it?
If so, try reloading the page.
  `.trim();
}
function webSocketTargetDisabled(targetName, enabledOutputs, disabledOutputs) {
  return `
The compiled JavaScript code running in the browser says it is for this target:

${targetName}

That target does exist in elm-watch.json, but isn't enabled.

These targets are enabled via CLI arguments:

${enabledOutputs.map((outputPath) => outputPath.targetName).join("\n")}

These targets exist in elm-watch.json but aren't enabled:

${disabledOutputs.map((outputPath) => outputPath.targetName).join("\n")}

If you want to have this target compiled, restart elm-watch either with more CLI arguments or no CLI arguments at all!
  `.trim();
}
function webSocketDecodeError(error) {
  return `
The compiled JavaScript code running in the browser seems to have sent a message that the web socket server cannot recognize!

${printJsonError(error).text}

The web socket code I generate is supposed to always send correct messages, so something is up here.
  `.trim();
}
function openEditorInvalidFilePath(file) {
  return `
I received a command to open the following file in your editor:

${file}

However, no target imports that file. For security reasons, I never executed any command with that file.
  `.trim();
}
function openEditorCommandFailed({
  error,
  command,
  cwd,
  timeout,
  env,
  stdout,
  stderr
}) {
  const errorReason = error.killed === true ? `The command took too long to run, and was killed after ${timeout} ms.` : error.code !== void 0 ? `The command exited with code ${error.code}.` : "The command failed for an unknown reason.";
  return `
I ran your command for opening an editor (set via the ${ELM_WATCH_OPEN_EDITOR} environment variable):

${commandToPresentationName(["cd", cwd])}
${command}

I ran the command with these extra environment variables:

${Codec8.JSON.stringify(Codec8.unknown, env, 2)}

${errorReason}

${printStdio(stdout, stderr)(DEFAULT_COLUMNS, (piece) => piece.text)}
  `.trim();
}
function printPATH(env, isWindows) {
  if (isWindows) {
    return printPATHWindows(env);
  }
  const { PATH } = env;
  if (PATH === void 0) {
    return template`I can't find any program, because process.env.PATH is undefined!`;
  }
  const pathList = PATH.split(path3.delimiter);
  return template`
This is what the PATH environment variable looks like:

${join2(pathList, "\n")}
  `;
}
function printPATHWindows(env) {
  const pathEntries = Object.entries(env).flatMap(
    ([key, value]) => key.toUpperCase() === "PATH" && value !== void 0 ? [[key, value]] : []
  );
  if (!isNonEmptyArray(pathEntries)) {
    return template`I can't find any program, because I can't find any PATH-like environment variables!`;
  }
  if (pathEntries.length === 1) {
    const [key, value] = pathEntries[0];
    return template`
This is what the ${text(key)} environment variable looks like:

${join2(value.split(path3.delimiter), "\n")}
    `;
  }
  const pathEntriesString = join2(
    pathEntries.map(
      ([key, value]) => [`${key}:`, ...value.split(path3.delimiter)].join("\n")
    ),
    "\n\n"
  );
  return template`
You seem to have several PATH-like environment variables set. The last one
should be the one that is actually used, but it's better to have a single one!

${pathEntriesString}
  `;
}
function printCommand(command) {
  const stdin = command.stdin === void 0 ? "" : `${commandToPresentationName([
    "printf",
    truncate(command.stdin.toString("utf8"))
  ])} | `;
  return text(`
${commandToPresentationName(["cd", command.options.cwd])}
${stdin}${commandToPresentationName([command.command, ...command.args])}
`);
}
function commandToPresentationName(command) {
  return command.map(
    (part) => part === "" ? "''" : part.split(/(')/).map(
      (subPart) => subPart === "" ? "" : subPart === "'" ? "\\'" : /^[\w.,:/=@%+-]+$/.test(subPart) ? subPart : `'${subPart}'`
    ).join("")
  ).join(" ");
}
function printExitReason(exitReason2) {
  switch (exitReason2.tag) {
    case "ExitCode":
      return text(`exit ${exitReason2.exitCode}`);
    case "Signal":
      return text(`signal ${exitReason2.signal}`);
    case "Unknown":
      return text("unknown exit reason");
  }
}
function printStdio(stdout, stderr) {
  return stdout !== "" && stderr === "" ? limitStdio(stdout) : stdout === "" && stderr !== "" ? limitStdio(stderr) : stdout === "" && stderr === "" ? template`${dim2("(no output)")}` : template`
STDOUT:
${limitStdio(stdout)}

STDERR:
${limitStdio(stderr)}
`;
}
function printElmWatchNodeStdio(stdout, stderr) {
  return stdout === "" && stderr === "" ? template`` : template`
STDOUT:
${limitStdio(stdout)}

STDERR:
${limitStdio(stderr)}
`;
}
var limitStdio = (string9) => (width, renderPiece) => {
  const max = 100;
  const lines = string9.trimEnd().split("\n");
  const result = [];
  let usedLines = 0;
  for (const line of lines) {
    const count = Math.ceil(line.length / width);
    const available = max - usedLines;
    if (available <= 0) {
      break;
    } else if (count > available) {
      const take = available * width;
      const left2 = line.length - take;
      result.push(
        `${line.slice(0, take)} ${renderPiece(
          dim2(left2 === 1 ? "1 more character" : `${left2} more characters`)
        )}`
      );
      usedLines += available;
      break;
    } else {
      result.push(line);
      usedLines += count;
    }
  }
  const joined = result.join("\n");
  const left = lines.length - result.length;
  return left > 0 ? `${joined}
${renderPiece(
    dim2(left === 1 ? "1 more line" : `${left} more lines`)
  )}` : joined;
};
function printErrorFilePath(errorFilePath) {
  switch (errorFilePath.tag) {
    case "AbsolutePath":
      return template`
I wrote that to this file so you can inspect it:

${text(errorFilePath.theAbsolutePath)}
      `;
    case "WritingErrorFileFailed":
      return template`
I tried to write that to this file:

${text(errorFilePath.attemptedPath)}

${bold2("But that failed too:")}

${text(errorFilePath.error.message)}
      `;
    case "ErrorFileBadContent":
      return template`
I wrote this error to a file so you can inspect and possibly report it more easily.

This is the data that caused the error:

${text(errorFilePath.content)}
      `;
  }
}
function printUnknownValueAsString(value) {
  switch (value.tag) {
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    case "UnknownValueAsString":
      return text(value.value);
  }
}
function printElmWatchNodeImportCommand(scriptPath) {
  return template`const imported = await import(${json(scriptPath)})`;
}
function printElmWatchNodeRunCommand(args) {
  const truncated = {
    ...args,
    code: truncate(args.code)
  };
  return template`const result = await imported.default(${json(truncated, 2)})`;
}
function truncate(string9) {
  const roughLimit = 20;
  const half = Math.floor(roughLimit / 2);
  return string9.length <= roughLimit ? string9 : `${string9.slice(0, half)}...${string9.slice(-half)}`;
}
function printJsonError(error) {
  return text(Codec8.format(error));
}
function tryWriteErrorFile({
  cwd,
  name,
  content,
  hash
}) {
  const jsonPath = absolutePathFromString(
    cwd,
    `elm-watch-${name}-${sha256(hash)}.txt`
  );
  try {
    fs2.writeFileSync(jsonPath, content);
    return { tag: "AbsolutePath", theAbsolutePath: jsonPath };
  } catch (unknownError) {
    const error = toError(unknownError);
    return {
      tag: "WritingErrorFileFailed",
      error,
      attemptedPath: jsonPath
    };
  }
}
function sha256(string9) {
  return crypto.createHash("sha256").update(string9).digest("hex");
}

// src/ImportWalker.ts
var fs3 = require("fs");
var path4 = require("path");

// src/Parser.ts
var MODULE_NAME = /^\p{Lu}[_\d\p{L}]*(?:\.\p{Lu}[_\d\p{L}]*)*$/u;
var CR = 13;
var HYPHEN = 45;
var LEFT_BRACE = 123;
var LF = 10;
var RIGHT_BRACE = 125;
var SPACE = 32;
function isImport(chars) {
  return chars.length === 6 && chars[0] === 105 && chars[1] === 109 && chars[2] === 112 && chars[3] === 111 && chars[4] === 114 && chars[5] === 116;
}
var initialReadState = () => ({
  tokenizerState: { tag: "Initial", chars: [], multilineCommentLevel: 0 },
  parserState: { tag: "StartOfFile" },
  importedModules: []
});
function readChar(char, readState) {
  const maybeToken = tokenize(char, readState.tokenizerState);
  if (maybeToken === void 0) {
    return;
  }
  const maybeModuleName = parse2(maybeToken, readState.parserState);
  if (maybeModuleName !== void 0) {
    readState.importedModules.push(maybeModuleName);
  }
}
function isNonImport(readState) {
  return readState.parserState.tag === "NonImport";
}
function finalize(readState) {
  if (readState.tokenizerState.tag !== "Initial") {
    return readState.importedModules;
  }
  const maybeLastToken = flush(readState.tokenizerState.chars);
  if (maybeLastToken === void 0) {
    return readState.importedModules;
  }
  const maybeLastModuleName = parse2(maybeLastToken, readState.parserState);
  if (maybeLastModuleName === void 0) {
    return readState.importedModules;
  }
  readState.importedModules.push(maybeLastModuleName);
  return readState.importedModules;
}
function tokenize(char, tokenizerState) {
  switch (tokenizerState.tag) {
    case "Initial":
      switch (char) {
        case SPACE: {
          const maybeToken = flush(tokenizerState.chars);
          tokenizerState.chars = [];
          return maybeToken;
        }
        case CR:
        case LF:
          tokenizerState.tag = "MaybeNewChunk";
          return flush(tokenizerState.chars);
        case LEFT_BRACE:
          tokenizerState.tag = "MaybeMultilineComment{";
          return flush(tokenizerState.chars);
        case HYPHEN:
          tokenizerState.tag = "MaybeSinglelineComment-";
          return flush(tokenizerState.chars);
        default:
          tokenizerState.chars.push(char);
          return void 0;
      }
    case "MaybeNewChunk":
      switch (char) {
        case SPACE:
          tokenizerState.tag = "Initial";
          tokenizerState.chars = [];
          return void 0;
        case CR:
        case LF:
          return void 0;
        case LEFT_BRACE:
          tokenizerState.tag = "MaybeMultilineComment{";
          return void 0;
        case HYPHEN:
          tokenizerState.tag = "MaybeSinglelineComment-";
          return void 0;
        default:
          tokenizerState.tag = "Initial";
          tokenizerState.chars = [char];
          return { tag: "NewChunk" };
      }
    case "MaybeMultilineComment{":
      switch (char) {
        case HYPHEN:
          tokenizerState.tag = "MultilineComment";
          tokenizerState.multilineCommentLevel = 1;
          return void 0;
        default:
          tokenizerState.tag = "Initial";
          tokenizerState.chars = [LEFT_BRACE];
          return tokenize(char, tokenizerState);
      }
    case "MultilineComment":
      switch (char) {
        case LEFT_BRACE:
          tokenizerState.tag = "MultilineComment{";
          return void 0;
        case HYPHEN:
          tokenizerState.tag = "MultilineComment-";
          return void 0;
        default:
          return void 0;
      }
    case "MultilineComment{":
      switch (char) {
        case HYPHEN:
          tokenizerState.tag = "MultilineComment";
          tokenizerState.multilineCommentLevel++;
          return void 0;
        case LEFT_BRACE:
          return void 0;
        default:
          tokenizerState.tag = "MultilineComment";
          return void 0;
      }
    case "MultilineComment-":
      switch (char) {
        case RIGHT_BRACE:
          if (tokenizerState.multilineCommentLevel <= 1) {
            tokenizerState.tag = "Initial";
            tokenizerState.chars = [];
          } else {
            tokenizerState.tag = "MultilineComment";
            tokenizerState.multilineCommentLevel--;
          }
          return void 0;
        case LEFT_BRACE:
          tokenizerState.tag = "MultilineComment{";
          return void 0;
        case HYPHEN:
          return void 0;
        default:
          tokenizerState.tag = "MultilineComment";
          return void 0;
      }
    case "MaybeSinglelineComment-":
      switch (char) {
        case HYPHEN:
          tokenizerState.tag = "SinglelineComment";
          return void 0;
        default:
          tokenizerState.tag = "Initial";
          tokenizerState.chars = [HYPHEN];
          return tokenize(char, tokenizerState);
      }
    case "SinglelineComment":
      switch (char) {
        case CR:
        case LF:
          tokenizerState.tag = "MaybeNewChunk";
          return void 0;
        default:
          return void 0;
      }
  }
}
function flush(chars) {
  return isNonEmptyArray(chars) ? { tag: "Word", chars } : void 0;
}
function parse2(token, parserState) {
  switch (parserState.tag) {
    case "StartOfFile":
      switch (token.tag) {
        case "NewChunk":
          return void 0;
        case "Word":
          if (isImport(token.chars)) {
            parserState.tag = "Import";
            return void 0;
          } else {
            parserState.tag = "Ignore";
            return void 0;
          }
      }
    case "NewChunk":
      switch (token.tag) {
        /* v8 ignore start */
        case "NewChunk":
          return void 0;
        /* v8 ignore stop */
        case "Word":
          if (isImport(token.chars)) {
            parserState.tag = "Import";
            return void 0;
          } else {
            parserState.tag = "NonImport";
            return void 0;
          }
      }
    case "Import":
      switch (token.tag) {
        case "NewChunk":
          parserState.tag = "NewChunk";
          return void 0;
        case "Word": {
          const string9 = Buffer.from(token.chars).toString();
          if (MODULE_NAME.test(string9)) {
            parserState.tag = "Ignore";
            return split(string9, ".");
          } else {
            parserState.tag = "Ignore";
            return void 0;
          }
        }
      }
    case "Ignore":
      switch (token.tag) {
        case "NewChunk":
          parserState.tag = "NewChunk";
          return void 0;
        case "Word":
          return void 0;
      }
    case "NonImport":
      return void 0;
  }
}

// src/ImportWalker.ts
function walkImports(sourceDirectories, inputRealPaths) {
  const allRelatedElmFilePaths = new Set(
    inputRealPaths.flatMap(
      (inputRealPath) => initialRelatedElmFilePaths(sourceDirectories, inputRealPath)
    )
  );
  const visitedModules = /* @__PURE__ */ new Set();
  try {
    for (const inputRealPath of inputRealPaths) {
      walkImportsHelper(
        mapNonEmptyArray(sourceDirectories, (sourceDirectory) => ({
          sourceDirectory,
          children: new Set(readdirSync2(sourceDirectory))
        })),
        inputRealPath,
        allRelatedElmFilePaths,
        visitedModules
      );
    }
  } catch (unknownError) {
    const error = toError(unknownError);
    return {
      tag: "ImportWalkerFileSystemError",
      error,
      relatedElmFilePathsUntilError: allRelatedElmFilePaths
    };
  }
  return { tag: "Success", allRelatedElmFilePaths };
}
function walkImportsHelper(sourceDirectories, elmFilePath, allRelatedElmFilePaths, visitedModules) {
  if (!fs3.existsSync(elmFilePath)) {
    return;
  }
  const importedModules = parse3(elmFilePath);
  for (const importedModule of importedModules) {
    const relativePath = `${importedModule.join(path4.sep)}.elm`;
    if (!visitedModules.has(relativePath)) {
      visitedModules.add(relativePath);
      for (const { sourceDirectory, children } of sourceDirectories) {
        const newElmFilePath = markAsAbsolutePath(
          sourceDirectory + path4.sep + relativePath
        );
        allRelatedElmFilePaths.add(newElmFilePath);
        const child = importedModule.length === 1 ? `${importedModule[0]}.elm` : importedModule[0];
        if (children.has(child)) {
          walkImportsHelper(
            sourceDirectories,
            newElmFilePath,
            allRelatedElmFilePaths,
            visitedModules
          );
        }
      }
    }
  }
}
function parse3(elmFilePath) {
  const readState = initialReadState();
  const handle = fs3.openSync(elmFilePath, "r");
  const buffer = Buffer.alloc(2048);
  let bytesRead = 0;
  outer: while ((bytesRead = fs3.readSync(handle, buffer)) > 0) {
    for (const char of buffer.subarray(0, bytesRead)) {
      readChar(char, readState);
      if (isNonImport(readState)) {
        break outer;
      }
    }
  }
  fs3.closeSync(handle);
  return finalize(readState);
}
function initialRelatedElmFilePaths(sourceDirectories, inputRealPath) {
  return [
    inputRealPath,
    ...sourceDirectories.flatMap((sourceDirectory) => {
      const prefix = sourceDirectory + path4.sep;
      return inputRealPath.startsWith(prefix) ? sourceDirectories.map(
        (sourceDirectory2) => markAsAbsolutePath(
          sourceDirectory2 + path4.sep + inputRealPath.slice(prefix.length)
        )
      ) : [];
    })
  ];
}
function readdirSync2(dir) {
  try {
    return fs3.readdirSync(dir);
  } catch {
    return [];
  }
}

// src/Inject.ts
var Codec9 = require("tiny-decoders");
var ClientCode = require("./ClientCode");
var REPLACEMENT_REGEX = /^(?:function (F|_Platform_initialize|_Platform_export|_Browser_application|_Scheduler_binding|_Scheduler_step)\(|var (_VirtualDom_init|\$elm\$browser\$Browser\$sandbox|_Platform_worker|_Browser_element|_Browser_document|_Debugger_element|_Debugger_document) =).*\r?\n?\{(?:.*\r?\n)*?\}\)?;?$/gm;
var PLACEHOLDER_REGEX = /%(\w+)%/g;
var REPLACEMENTS = {
  // ### _Platform_initialize (main : Program flags model msg)
  // New implementation.
  // Note: `isDebug` is needed when you have programs that do and don’t support
  // the debugger in the same output. `$elm$browser$Debugger$Main$wrapUpdate`
  // etc is going to be defined, but it should only be used in
  // `_Platform_initialize` when actually called from `_Debugger_element` or
  // `_Debugger_document`, not from `_Platform_worker`. (`Html` programs don’t
  // call `_Platform_initialize`.)
  _Platform_initialize: `
// added by elm-watch
var _elmWatchTargetName = "";

// This whole function was changed by elm-watch.
function _Platform_initialize(programType, isDebug, debugMetadata, flagDecoder, args, init, impl, stepperBuilder)
{
	if (args === "__elmWatchReturnData") {
		return { impl: impl, debugMetadata: debugMetadata, flagDecoder : flagDecoder, programType: programType, _Platform_effectManagers: _Platform_effectManagers, _Scheduler_enqueue: _Scheduler_enqueue };
	}

	var flags = _Json_wrap(args ? args['flags'] : undefined);
	var flagResult = A2(_Json_run, flagDecoder, flags);
	$elm$core$Result$isOk(flagResult) || _Debug_crash(2 /**/, _Json_errorToString(flagResult.a) /**/);
	var managers = {};
	var initUrl = programType === "Browser.application" ? _Browser_getUrl() : undefined;
	globalThis.__ELM_WATCH_INIT_URL = initUrl;
	var initPair = init(flagResult.a);
	delete globalThis.__ELM_WATCH_INIT_URL;
	var model = initPair.a;
	var stepper = stepperBuilder(sendToApp, model);
	var ports = _Platform_setupEffects(managers, sendToApp);
	var update;
	var subscriptions;

	function setUpdateAndSubscriptions() {
		update = impl.%update% || impl._impl.%update%;
		subscriptions = impl.%subscriptions% || impl._impl.%subscriptions%;
		if (isDebug) {
			update = $elm$browser$Debugger$Main$wrapUpdate(update);
			subscriptions = $elm$browser$Debugger$Main$wrapSubs(subscriptions);
		}
	}

	function sendToApp(msg, viewMetadata) {
		var pair = A2(update, msg, model);
		stepper(model = pair.a, viewMetadata);
		_Platform_enqueueEffects(managers, pair.b, subscriptions(model));
	}

	setUpdateAndSubscriptions();

	var skippedInitCmds = globalThis.__ELM_WATCH ? globalThis.__ELM_WATCH.SHOULD_SKIP_INIT_CMDS(_elmWatchTargetName) : false;

	_Platform_enqueueEffects(managers, skippedInitCmds ? _Platform_batch(_List_Nil) : initPair.b, subscriptions(model));

	function __elmWatchHotReload(newData) {
		_Platform_enqueueEffects(managers, _Platform_batch(_List_Nil), _Platform_batch(_List_Nil));
		_Scheduler_enqueue = newData._Scheduler_enqueue;

		var reloadReasons = [];

		for (var key in newData._Platform_effectManagers) {
			var manager = newData._Platform_effectManagers[key];
			if (!(key in _Platform_effectManagers)) {
				_Platform_effectManagers[key] = manager;
				managers[key] = _Platform_instantiateManager(manager, sendToApp);
				if (manager.a) {
					reloadReasons.push({ tag: "NewPortAdded", name: key });
					manager.a(key, sendToApp)
				}
			}
		}

		for (var key in newData.impl) {
			if (key === "_impl" && impl._impl) {
				for (var subKey in newData.impl[key]) {
					impl._impl[subKey] = newData.impl[key][subKey];
				}
			} else {
				impl[key] = newData.impl[key];
			}
		}

		var newFlagResult = A2(_Json_run, newData.flagDecoder, flags);
		if (!$elm$core$Result$isOk(newFlagResult)) {
			return reloadReasons.concat({ tag: "FlagsTypeChanged", jsonErrorMessage: _Json_errorToString(newFlagResult.a) });
		}
		if (!_Utils_eq_elmWatchInternal(debugMetadata, newData.debugMetadata)) {
			return reloadReasons.concat({ tag: "MessageTypeChangedInDebugMode" });
		}
		init = impl.%init% || impl._impl.%init%;
		if (isDebug) {
			init = A3($elm$browser$Debugger$Main$wrapInit, _Json_wrap(newData.debugMetadata), initPair.a.popout, init);
		}
		globalThis.__ELM_WATCH_INIT_URL = initUrl;
		var newInitPair = init(newFlagResult.a);
		delete globalThis.__ELM_WATCH_INIT_URL;
		if (!_Utils_eq_elmWatchInternal(initPair, newInitPair)) {
			return reloadReasons.concat({ tag: "InitReturnValueChanged" });
		}

		setUpdateAndSubscriptions();
		stepper(model, true /* isSync */);
		_Platform_enqueueEffects(managers, skippedInitCmds ? newInitPair.b : _Platform_batch(_List_Nil), subscriptions(model));
		skippedInitCmds = false;
		return reloadReasons;
	}

	function __elmWatchRunInitCmds() {
		if (skippedInitCmds) {
			_Platform_enqueueEffects(managers, initPair.b, subscriptions(model));
			skippedInitCmds = false;
		}
	}

	return Object.defineProperties(
		ports ? { ports: ports } : {},
		{
			__elmWatchHotReload: { value: __elmWatchHotReload },
			__elmWatchRunInitCmds: { value: __elmWatchRunInitCmds },
			__elmWatchProgramType: { value: programType },
		}
	);
}

// This whole function was added by elm-watch.
// Copy-paste of _Utils_eq but does not assume that x and y have the same type,
// and considers functions to always be equal.
function _Utils_eq_elmWatchInternal(x, y)
{
	for (
		var pair, stack = [], isEqual = _Utils_eqHelp_elmWatchInternal(x, y, 0, stack);
		isEqual && (pair = stack.pop());
		isEqual = _Utils_eqHelp_elmWatchInternal(pair.a, pair.b, 0, stack)
		)
	{}

	return isEqual;
}

// This whole function was added by elm-watch.
function _Utils_eqHelp_elmWatchInternal(x, y, depth, stack)
{
	if (x === y) {
		return true;
	}

	var xType = _Utils_typeof_elmWatchInternal(x);
	var yType = _Utils_typeof_elmWatchInternal(y);

	if (xType !== yType) {
		return false;
	}

	switch (xType) {
		case "primitive":
			return false;
		case "function":
			return true;
	}

	if (x.$ !== y.$) {
		return false;
	}

	if (x.$ === 'Set_elm_builtin') {
		x = $elm$core$Set$toList(x);
		y = $elm$core$Set$toList(y);
	} else if (x.$ === 'RBNode_elm_builtin' || x.$ === 'RBEmpty_elm_builtin' || x.$ < 0) {
		x = $elm$core$Dict$toList(x);
		y = $elm$core$Dict$toList(y);
	}

	if (Object.keys(x).length !== Object.keys(y).length) {
		return false;
	}

	if (depth > 100) {
		stack.push(_Utils_Tuple2(x, y));
		return true;
	}

	for (var key in x) {
		if (!_Utils_eqHelp_elmWatchInternal(x[key], y[key], depth + 1, stack)) {
			return false;
		}
	}
	return true;
}

// This whole function was added by elm-watch.
function _Utils_typeof_elmWatchInternal(x)
{
	var type = typeof x;
	return type === "function"
		? "function"
		: type !== "object" || type === null
		? "primitive"
		: "objectOrArray";
}
				`.trim(),
  // Make sure these are always defined for easier code in `_Platform_initialize`.
  // We don’t actually do anything with the `F` function – it’s just a way to get
  // these definitions near the top of the file.
  F: `
var _Platform_effectManagers = {}, _Scheduler_enqueue; // added by elm-watch

function F(arity, fun, wrapper) {
  wrapper.a = arity;
  wrapper.f = fun;
  return wrapper;
}
  `.trim(),
  // ### _VirtualDom_init (main : Html msg)
  // New implementation.
  _VirtualDom_init: `
// This whole function was changed by elm-watch.
var _VirtualDom_init = F4(function(virtualNode, flagDecoder, debugMetadata, args)
{
	var programType = "Html";

	if (args === "__elmWatchReturnData") {
		return { virtualNode: virtualNode, programType: programType, _Platform_effectManagers: _Platform_effectManagers, _Scheduler_enqueue: _Scheduler_enqueue };
	}

	/**_UNUSED/ // always UNUSED with elm-watch
	var node = args['node'];
	//*/
	/**/
	var node = args && args['node'] ? args['node'] : _Debug_crash(0);
	//*/

	var nextNode = _VirtualDom_render(virtualNode, function() {});
	node.parentNode.replaceChild(nextNode, node);
	node = nextNode;
	var sendToApp = function() {};

	function __elmWatchHotReload(newData) {
		var patches = _VirtualDom_diff(virtualNode, newData.virtualNode);
		node = _VirtualDom_applyPatches(node, virtualNode, patches, sendToApp);
		virtualNode = newData.virtualNode;
		return [];
	}

	return Object.defineProperties(
		{},
		{
			__elmWatchHotReload: { value: __elmWatchHotReload },
			__elmWatchRunInitCmds: { value: Function.prototype },
			__elmWatchProgramType: { value: programType },
		}
	);
});
				`.trim(),
  // ### _Platform_export
  // Allow registering the exports, and skipping the usual merging of `window.Elm` (for hot reloading).
  _Platform_export: `
function _Platform_export(exports)
{
	// added by elm-watch
	if (globalThis.__ELM_WATCH) {
		if (globalThis.__ELM_WATCH.IS_REGISTERING) {
			globalThis.__ELM_WATCH.REGISTER(_elmWatchTargetName, exports);
		} else {
			globalThis.__ELM_WATCH.HOT_RELOAD(_elmWatchTargetName, exports);
			return;
		}
	}

	scope['Elm']
		? _Platform_mergeExportsDebug('Elm', scope['Elm'], exports) // Always calls the debug version with elm-watch (the only difference is an error message).
		: scope['Elm'] = exports;
}
				`.trim(),
  // ### _Browser_application
  // Don’t pluck things out of `impl`. Pass `impl` to `_Browser_document`. Init
  // with URL given from `_Platform_initialize` (via `globalThis.__ELM_WATCH_INIT_URL`).
  _Browser_application: `
// This function was slightly modified by elm-watch.
function _Browser_application(impl)
{
	// var onUrlChange = impl.onUrlChange; // commented out by elm-watch
	// var onUrlRequest = impl.onUrlRequest; // commented out by elm-watch
	// var key = function() { key.a(onUrlChange(_Browser_getUrl())); }; // commented out by elm-watch
	var key = function() { key.a(impl.%onUrlChange%(_Browser_getUrl())); }; // added by elm-watch

	return _Browser_document({
		%setup%: function(sendToApp)
		{
			key.a = sendToApp;
			_Browser_window.addEventListener('popstate', key);
			_Browser_window.navigator.userAgent.indexOf('Trident') < 0 || _Browser_window.addEventListener('hashchange', key);

			return F2(function(domNode, event)
			{
				if (!event.ctrlKey && !event.metaKey && !event.shiftKey && event.button < 1 && !domNode.target && !domNode.hasAttribute('download'))
				{
					event.preventDefault();
					var href = domNode.href;
					var curr = _Browser_getUrl();
					var next = $elm$url$Url$fromString(href).a;
					sendToApp(impl.%onUrlRequest%(
						(next
							&& curr.%protocol% === next.%protocol%
							&& curr.%host% === next.%host%
							&& curr.%port_%.a === next.%port_%.a
						)
							? $elm$browser$Browser$Internal(next)
							: $elm$browser$Browser$External(href)
					));
				}
			});
		},
		%init%: function(flags)
		{
			// return A3(impl.init, flags, _Browser_getUrl(), key); // commented out by elm-watch
			return A3(impl.%init%, flags, globalThis.__ELM_WATCH_INIT_URL, key); // added by elm-watch
		},
		// view: impl.view, // commented out by elm-watch
		// update: impl.update, // commented out by elm-watch
		// subscriptions: impl.subscriptions // commented out by elm-watch
		%view%: function(model) { return impl.%view%(model); }, // added by elm-watch
		_impl: impl // added by elm-watch
	});
}
  `.trim(),
  // ### $elm$browser$Browser$sandbox
  // Don’t pluck `view` from `impl`. Pass `impl` to `_Browser_element`.
  $elm$browser$Browser$sandbox: `
// This function was slightly modified by elm-watch.
var $elm$browser$Browser$sandbox = function (impl) {
	return _Browser_element(
		{
			%init%: function (_v0) {
				return _Utils_Tuple2(impl.%init%, $elm$core$Platform$Cmd$none);
			},
			%subscriptions%: function (_v1) {
				return $elm$core$Platform$Sub$none;
			},
			%update%: F2(
				function (msg, model) {
					return _Utils_Tuple2(
						A2(impl.%update%, msg, model),
						$elm$core$Platform$Cmd$none);
				}),
			// view: impl.view // commented out by elm-watch
			%view%: function(model) { return impl.%view%(model); }, // added by elm-watch
			_impl: impl // added by elm-watch
		});
};
  `.trim(),
  // ### _Platform_worker, _Browser_element, _Browser_document, _Debugger_element, _Debugger_document
  // Update call to `_Platform_initialize` to match our implementation.
  // `_Browser_application` calls `_Browser_document`/`_Debugger_document`.
  // `$elm$browser$Browser$sandbox` calls `_Browser_element`/`_Debugger_element`.
  // In those cases we need `impl._impl`.
  // Don’t pluck `view` from `impl`.
  // Also pass the type of program, `isDebug` and the `debugMetadata` to `_Platform_initialize`.
  _Platform_worker: `
// This function was slightly modified by elm-watch.
var _Platform_worker = F4(function(impl, flagDecoder, debugMetadata, args)
{
	return _Platform_initialize(
		"Platform.worker", // added by elm-watch
		false, // isDebug, added by elm-watch
		debugMetadata, // added by elm-watch
		flagDecoder,
		args,
		impl.%init%,
		// impl.update, // commented out by elm-watch
		// impl.subscriptions, // commented out by elm-watch
		impl, // added by elm-watch
		function() { return function() {} }
	);
});
  `.trim(),
  _Browser_element: `
// This function was slightly modified by elm-watch.
var _Browser_element = _Debugger_element || F4(function(impl, flagDecoder, debugMetadata, args)
{
	return _Platform_initialize(
		impl._impl ? "Browser.sandbox" : "Browser.element", // added by elm-watch
		false, // isDebug, added by elm-watch
		debugMetadata, // added by elm-watch
		flagDecoder,
		args,
		impl.%init%,
		// impl.update, // commented out by elm-watch
		// impl.subscriptions, // commented out by elm-watch
		impl, // added by elm-watch
		function(sendToApp, initialModel) {
			// var view = impl.view; // commented out by elm-watch
			/**_UNUSED/ // always UNUSED with elm-watch
			var domNode = args['node'];
			//*/
			/**/
			var domNode = args && args['node'] ? args['node'] : _Debug_crash(0);
			//*/
			var currNode = _VirtualDom_virtualize(domNode);

			return _Browser_makeAnimator(initialModel, function(model)
			{
				// var nextNode = view(model); // commented out by elm-watch
				var nextNode = impl.%view%(model); // added by elm-watch
				var patches = _VirtualDom_diff(currNode, nextNode);
				domNode = _VirtualDom_applyPatches(domNode, currNode, patches, sendToApp);
				currNode = nextNode;
			});
		}
	);
});
  `.trim(),
  _Browser_document: `
// This function was slightly modified by elm-watch.
var _Browser_document = _Debugger_document || F4(function(impl, flagDecoder, debugMetadata, args)
{
	return _Platform_initialize(
		impl._impl ? "Browser.application" : "Browser.document", // added by elm-watch
		false, // isDebug, added by elm-watch
		debugMetadata, // added by elm-watch
		flagDecoder,
		args,
		impl.%init%,
		// impl.update, // commented out by elm-watch
		// impl.subscriptions, // commented out by elm-watch
		impl, // added by elm-watch
		function(sendToApp, initialModel) {
			var divertHrefToApp = impl.%setup% && impl.%setup%(sendToApp)
			// var view = impl.view; // commented out by elm-watch
			var title = _VirtualDom_doc.title;
			var bodyNode = _VirtualDom_doc.body;
			_VirtualDom_divertHrefToApp = divertHrefToApp; // added by elm-watch
			var currNode = _VirtualDom_virtualize(bodyNode);
			_VirtualDom_divertHrefToApp = 0; // added by elm-watch
			return _Browser_makeAnimator(initialModel, function(model)
			{
				_VirtualDom_divertHrefToApp = divertHrefToApp;
				// var doc = view(model); // commented out by elm-watch
				var doc = impl.%view%(model); // added by elm-watch
				var nextNode = _VirtualDom_node('body')(_List_Nil)(doc.%body%);
				var patches = _VirtualDom_diff(currNode, nextNode);
				bodyNode = _VirtualDom_applyPatches(bodyNode, currNode, patches, sendToApp);
				currNode = nextNode;
				_VirtualDom_divertHrefToApp = 0;
				(title !== doc.%title%) && (_VirtualDom_doc.title = title = doc.%title%);
			});
		}
	);
});
  `.trim(),
  // Note: Debugger code does not need to worry about optimize mode shortened record fields.
  _Debugger_element: `
// This function was slightly modified by elm-watch.
var _Debugger_element = F4(function(impl, flagDecoder, debugMetadata, args)
{
	return _Platform_initialize(
		impl._impl ? "Browser.sandbox" : "Browser.element", // added by elm-watch
		true, // isDebug, added by elm-watch
		debugMetadata, // added by elm-watch
		flagDecoder,
		args,
		A3($elm$browser$Debugger$Main$wrapInit, _Json_wrap(debugMetadata), _Debugger_popout(), impl.init),
		// $elm$browser$Debugger$Main$wrapUpdate(impl.update), // commented out by elm-watch
		// $elm$browser$Debugger$Main$wrapSubs(impl.subscriptions), // commented out by elm-watch
		impl, // added by elm-watch
		function(sendToApp, initialModel)
		{
			// var view = impl.view; // commented out by elm-watch
			var title = _VirtualDom_doc.title;
			var domNode = args && args['node'] ? args['node'] : _Debug_crash(0);
			var currNode = _VirtualDom_virtualize(domNode);
			var currBlocker = $elm$browser$Debugger$Main$toBlockerType(initialModel);
			var currPopout;

			var cornerNode = _VirtualDom_doc.createElement('div');
			domNode.parentNode.insertBefore(cornerNode, domNode.nextSibling);
			var cornerCurr = _VirtualDom_virtualize(cornerNode);

			initialModel.popout.a = sendToApp;

			return _Browser_makeAnimator(initialModel, function(model)
			{
				// var nextNode = A2(_VirtualDom_map, $elm$browser$Debugger$Main$UserMsg, view($elm$browser$Debugger$Main$getUserModel(model))); // commented out by elm-watch
				var nextNode = A2(_VirtualDom_map, $elm$browser$Debugger$Main$UserMsg, impl.view($elm$browser$Debugger$Main$getUserModel(model))); // added by elm-watch
				var patches = _VirtualDom_diff(currNode, nextNode);
				domNode = _VirtualDom_applyPatches(domNode, currNode, patches, sendToApp);
				currNode = nextNode;

				// update blocker

				var nextBlocker = $elm$browser$Debugger$Main$toBlockerType(model);
				_Debugger_updateBlocker(currBlocker, nextBlocker);
				currBlocker = nextBlocker;

				// view corner

				var cornerNext = $elm$browser$Debugger$Main$cornerView(model);
				var cornerPatches = _VirtualDom_diff(cornerCurr, cornerNext);
				cornerNode = _VirtualDom_applyPatches(cornerNode, cornerCurr, cornerPatches, sendToApp);
				cornerCurr = cornerNext;

				if (!model.popout.b)
				{
					currPopout = undefined;
					return;
				}

				// view popout

				_VirtualDom_doc = model.popout.b; // SWITCH TO POPOUT DOC
				// currPopout || (currPopout = _VirtualDom_virtualize(model.popout.b)); // commented out by elm-watch
				currPopout || (currPopout = _VirtualDom_virtualize(model.popout.b.body)); // added by elm-watch
				var nextPopout = $elm$browser$Debugger$Main$popoutView(model);
				var popoutPatches = _VirtualDom_diff(currPopout, nextPopout);
				_VirtualDom_applyPatches(model.popout.b.body, currPopout, popoutPatches, sendToApp);
				currPopout = nextPopout;
				_VirtualDom_doc = document; // SWITCH BACK TO NORMAL DOC
			});
		}
	);
});
  `.trim(),
  _Debugger_document: `
// This function was slightly modified by elm-watch.
var _Debugger_document = F4(function(impl, flagDecoder, debugMetadata, args)
{
	return _Platform_initialize(
		impl._impl ? "Browser.application" : "Browser.document", // added by elm-watch
		true, // isDebug, added by elm-watch
		debugMetadata, // added by elm-watch
		flagDecoder,
		args,
		A3($elm$browser$Debugger$Main$wrapInit, _Json_wrap(debugMetadata), _Debugger_popout(), impl.init),
		// $elm$browser$Debugger$Main$wrapUpdate(impl.update), // commented out by elm-watch
		// $elm$browser$Debugger$Main$wrapSubs(impl.subscriptions), // commented out by elm-watch
		impl, // added by elm-watch
		function(sendToApp, initialModel)
		{
			var divertHrefToApp = impl.setup && impl.setup(function(x) { return sendToApp($elm$browser$Debugger$Main$UserMsg(x)); });
			// var view = impl.view; // commented out by elm-watch
			var title = _VirtualDom_doc.title;
			var bodyNode = _VirtualDom_doc.body;
			_VirtualDom_divertHrefToApp = divertHrefToApp; // added by elm-watch
			var currNode = _VirtualDom_virtualize(bodyNode);
			_VirtualDom_divertHrefToApp = 0; // added by elm-watch
			var currBlocker = $elm$browser$Debugger$Main$toBlockerType(initialModel);
			var currPopout;

			initialModel.popout.a = sendToApp;

			return _Browser_makeAnimator(initialModel, function(model)
			{
				_VirtualDom_divertHrefToApp = divertHrefToApp;
				// var doc = view($elm$browser$Debugger$Main$getUserModel(model)); // commented out by elm-watch
				var doc = impl.view($elm$browser$Debugger$Main$getUserModel(model)); // added by elm-watch
				var nextNode = _VirtualDom_node('body')(_List_Nil)(
					_Utils_ap(
						A2($elm$core$List$map, _VirtualDom_map($elm$browser$Debugger$Main$UserMsg), doc.body),
						_List_Cons($elm$browser$Debugger$Main$cornerView(model), _List_Nil)
					)
				);
				var patches = _VirtualDom_diff(currNode, nextNode);
				bodyNode = _VirtualDom_applyPatches(bodyNode, currNode, patches, sendToApp);
				currNode = nextNode;
				_VirtualDom_divertHrefToApp = 0;
				(title !== doc.title) && (_VirtualDom_doc.title = title = doc.title);

				// update blocker

				var nextBlocker = $elm$browser$Debugger$Main$toBlockerType(model);
				_Debugger_updateBlocker(currBlocker, nextBlocker);
				currBlocker = nextBlocker;

				// view popout

				if (!model.popout.b) { currPopout = undefined; return; }

				_VirtualDom_doc = model.popout.b; // SWITCH TO POPOUT DOC
				// currPopout || (currPopout = _VirtualDom_virtualize(model.popout.b)); // commented out by elm-watch
				currPopout || (currPopout = _VirtualDom_virtualize(model.popout.b.body)); // added by elm-watch
				var nextPopout = $elm$browser$Debugger$Main$popoutView(model);
				var popoutPatches = _VirtualDom_diff(currPopout, nextPopout);
				_VirtualDom_applyPatches(model.popout.b.body, currPopout, popoutPatches, sendToApp);
				currPopout = nextPopout;
				_VirtualDom_doc = document; // SWITCH BACK TO NORMAL DOC
			});
		}
	);
});
  `.trim(),
  // ### _Scheduler_binding, _Scheduler_step
  // This is needed because Elm mutates `Task`s in `_Scheduler_step`:
  //
  //     proc.__root.__kill = proc.__root.__callback(function(newRoot) {
  //
  // Some tasks are cancelable so `.__kill` is set to a function. Some are not,
  // and then `.__kill` seems to be set to `undefined`. But the initial value is
  // `null`! Later, there's just a truthiness check on `.__kill` so both `null` and
  // `undefined` works. However, this means that the “did `init` return the same
  // thing as last time?” check fails:
  //
  // - Either because of `null` vs `undefined`.
  // - Or because of `null` vs `function`.
  //
  // To solve this, make sure that `.__kill` (called `.c` in what we have to
  // work with below) is _always_ set to a function – a dummy one for
  // non-cancelable tasks (`Function.prototype` is a no-op function).
  // `_Utils_eq_elmWatchInternal` considers all functions to be equal.
  _Scheduler_binding: `
// This function was slightly modified by elm-watch.
function _Scheduler_binding(callback)
{
	return {
		$: 2,
		b: callback,
		// c: null // commented out by elm-watch
		c: Function.prototype // added by elm-watch
	};
}
  `.trim(),
  _Scheduler_step: `
function _Scheduler_step(proc)
{
	while (proc.f)
	{
		var rootTag = proc.f.$;
		if (rootTag === 0 || rootTag === 1)
		{
			while (proc.g && proc.g.$ !== rootTag)
			{
				proc.g = proc.g.i;
			}
			if (!proc.g)
			{
				return;
			}
			proc.f = proc.g.b(proc.f.a);
			proc.g = proc.g.i;
		}
		else if (rootTag === 2)
		{
			proc.f.c = proc.f.b(function(newRoot) {
				proc.f = newRoot;
				_Scheduler_enqueue(proc);
			// }); // commented out by elm-watch
			}) || Function.prototype; // added by elm-watch
			return;
		}
		else if (rootTag === 5)
		{
			if (proc.h.length === 0)
			{
				return;
			}
			proc.f = proc.f.b(proc.h.shift());
		}
		else // if (rootTag === 3 || rootTag === 4)
		{
			proc.g = {
				$: rootTag === 3 ? 0 : 1,
				b: proc.f.b,
				i: proc.g
			};
			proc.f = proc.f.d;
		}
	}
}
  `.trim()
};
var REPLACEMENTS_WITHOUT_PLACEHOLDERS = updateReplacements({}, REPLACEMENTS);
function inject(compilationMode, code, targetName) {
  const replacements = getReplacements(compilationMode, code);
  return code.replace(
    REPLACEMENT_REGEX,
    (match, name1, name = name1) => (
      /* v8 ignore start */
      replacements[name] ?? `${match} /* elm-watch ERROR: No replacement for function '${name}' was found! */`
    )
    /* v8 ignore stop */
  ).replace(
    /^var _elmWatchTargetName = "";$/m,
    /* v8 ignore next */
    `var _elmWatchTargetName = ${Codec9.JSON.stringify(Codec9.string, targetName ?? "")};`
  );
}
function getReplacements(compilationMode, code) {
  switch (compilationMode) {
    case "debug":
    case "standard":
      return REPLACEMENTS_WITHOUT_PLACEHOLDERS;
    case "optimize":
      return updateReplacements(getOptimizeModeRecordNames(code), REPLACEMENTS);
  }
}
function getOptimizeModeRecordNames(code) {
  const match1 = /^\s*impl\.([\w$]+),\s*impl\.([\w$]+),\s*impl\.([\w$]+),/m.exec(code);
  const match2 = /^\s*var divertHrefToApp = impl\.([\w$]+)/m.exec(code);
  const match3 = /^\s*var nextNode = _VirtualDom_node\('body'\)\(_List_Nil\)\(doc\.([\w$]+)\);/m.exec(
    code
  );
  const match4 = /^\s*\(title !== doc\.([\w$]+)\)/m.exec(code);
  const match5 = /^\s*&& curr\.([\w$]+) .*\s*&& curr\.([\w$]+) .*\s*&& curr\.([\w$]+)\..*/m.exec(
    code
  );
  const [
    ,
    init3 = "init_missing",
    update2 = "update_missing",
    subscriptions = "subscriptions_missing"
  ] = match1 ?? [];
  const [, setup = "setup_missing"] = match2 ?? [];
  const [, body = "body_missing"] = match3 ?? [];
  const [, title = "title_missing"] = match4 ?? [];
  const [
    ,
    protocol = "protocol_missing",
    host = "host_missing",
    port_ = "port__missing"
  ] = match5 ?? [];
  const extra = Object.fromEntries(
    Array.from(
      code.matchAll(/^\s*var ([\w$]+) = impl\.([\w$]+);/gm),
      /* v8 ignore next */
      ([, from = "from_missing", to = "to_missing"]) => [from, to]
    )
  );
  return {
    ...extra,
    init: init3,
    update: update2,
    subscriptions,
    setup,
    body,
    title,
    protocol,
    host,
    port_
  };
}
function updateReplacements(optimizeModeRecordNames, replacements) {
  return Object.fromEntries(
    Object.entries(replacements).map(([key, value]) => [
      key,
      updateString(optimizeModeRecordNames, value)
    ])
  );
}
function updateString(optimizeModeRecordNames, string9) {
  return string9.replace(
    PLACEHOLDER_REGEX,
    (_, name) => optimizeModeRecordNames[name] ?? name
  );
}
function proxyFile(outputPath, elmCompiledTimestamp, browserUiPosition, webSocketPort, webSocketToken, debug) {
  const clientCodeString = clientCode(
    outputPath,
    elmCompiledTimestamp,
    "proxy",
    browserUiPosition,
    webSocketPort,
    webSocketToken,
    debug
  );
  const proxyCodeString = ClientCode.proxy.replace(
    /"%TARGET_NAME%"/g,
    Codec9.JSON.stringify(Codec9.string, outputPath.targetName)
  ).replace(/__this__ = window/g, "__this__ = this");
  return `${clientCodeString}
${proxyCodeString}
0 && await/2//2; const Elm = globalThis.Elm; export { Elm as default, Elm as Elm }`;
}
function clientCode(outputPath, elmCompiledTimestamp, compilationMode, browserUiPosition, webSocketPort, webSocketToken, debug) {
  const replacements = {
    TARGET_NAME: outputPath.targetName,
    INITIAL_ELM_COMPILED_TIMESTAMP: elmCompiledTimestamp.toString(),
    ORIGINAL_COMPILATION_MODE: compilationMode,
    ORIGINAL_BROWSER_UI_POSITION: browserUiPosition,
    WEBSOCKET_PORT: webSocketPort.toString(),
    WEBSOCKET_TOKEN: webSocketToken,
    DEBUG: debug.toString()
  };
  return versionedIdentifier(outputPath.targetName, webSocketPort, webSocketToken) + ClientCode.client.replace(
    new RegExp(`"%(${Object.keys(replacements).join("|")})%"`, "g"),
    (_, name) => (
      /* v8 ignore next */
      Codec9.JSON.stringify(Codec9.string, replacements[name] ?? name)
    )
  );
}
function versionedIdentifier(targetName, webSocketPort, webSocketToken) {
  return `// elm-watch hot ${Codec9.JSON.stringify(Codec9.unknown, {
    version: "1.2.2",
    targetName,
    webSocketPort,
    webSocketToken
  })}
`;
}
var RECORD_FIELD_REGEX = /(['"])(?:(?!\1)[^\\\n\r]|\\(?:\r\n|[^]))*(\1)?|\/\*(?:[^*]|\*(?!\/))*(\*\/)?|\/\/.*|\.[\w$]{1,4}\b/g;
function getRecordFields(compilationMode, code) {
  switch (compilationMode) {
    case "debug":
    case "standard":
      return void 0;
    // If the set of accessed record field names changes in optimize mode, we cannot hot reload.
    case "optimize": {
      const matches = code.match(RECORD_FIELD_REGEX) ?? [];
      return new Set(matches.filter((string9) => string9.startsWith(".")));
    }
  }
}
function recordFieldsChanged(oldSet, newSet) {
  return !(oldSet === void 0 || newSet === void 0 || compareRecordFieldsHelper(oldSet) === compareRecordFieldsHelper(newSet));
}
function compareRecordFieldsHelper(set) {
  return Array.from(set).sort().join(",");
}

// src/Postprocess.ts
var path5 = require("path");
var Codec10 = require("tiny-decoders");
var import_worker_threads = require("worker_threads");

// src/Spawn.ts
var childProcess = require("child_process");
function spawn2(command) {
  let killed = false;
  let kill = () => {
    killed = true;
  };
  const promise = (actualSpawn) => new Promise((resolve3) => {
    if (killed) {
      resolve3({ tag: "Killed", command });
      return;
    }
    const child = actualSpawn(command.command, command.args, {
      ...command.options,
      cwd: command.options.cwd
    });
    const stdout = [];
    const stderr = [];
    child.on("error", (error) => {
      resolve3(
        /* v8 ignore start */
        error.code === "ENOENT" ? { tag: "CommandNotFoundError", command } : { tag: "OtherSpawnError", error, command }
        /* v8 ignore stop */
      );
    });
    let stdinWriteError = void 0;
    child.stdin.on("error", (error) => {
      if (error.code === "EPIPE" || error.code === "EOF") {
        const result = {
          tag: "StdinWriteError",
          error,
          command
        };
        stdinWriteError = {
          result,
          timeoutId: setTimeout(() => {
            resolve3(result);
          }, 500)
        };
      } else {
        resolve3({ tag: "OtherSpawnError", error, command });
      }
    });
    child.stdout.on("error", (error) => {
      resolve3({ tag: "OtherSpawnError", error, command });
    });
    child.stderr.on("error", (error) => {
      resolve3({ tag: "OtherSpawnError", error, command });
    });
    child.stdout.on("data", (chunk) => {
      stdout.push(chunk);
    });
    child.stderr.on("data", (chunk) => {
      stderr.push(chunk);
    });
    child.on("exit", (exitCode, signal) => {
      if (killed) {
      } else {
        if (exitCode === 0 && stdinWriteError !== void 0) {
          clearTimeout(stdinWriteError.timeoutId);
          resolve3(stdinWriteError.result);
        } else {
          resolve3({
            tag: "Exit",
            exitReason: exitReason(exitCode, signal),
            stdout: Buffer.concat(stdout),
            stderr: Buffer.concat(stderr),
            command
          });
        }
      }
    });
    kill = () => {
      if (!killed) {
        child.kill();
        resolve3({ tag: "Killed", command });
        killed = true;
      }
    };
    if (command.stdin !== void 0) {
      child.stdin.end(command.stdin);
    }
  });
  return {
    promise: IS_WINDOWS ? import("cross-spawn").then((crossSpawn) => promise(crossSpawn.spawn)) : promise(childProcess.spawn),
    kill: () => {
      kill();
    }
  };
}
function exitReason(exitCode, signal) {
  return exitCode !== null ? { tag: "ExitCode", exitCode } : signal !== null ? { tag: "Signal", signal } : { tag: "Unknown" };
}

// src/Postprocess.ts
function runPostprocess({
  env,
  elmWatchJsonPath,
  compilationMode,
  runMode,
  outputPath: output,
  postprocessArray,
  code,
  postprocessWorkerPool
}) {
  const commandName = postprocessArray[0];
  const userArgs = postprocessArray.slice(1);
  const cwd = absoluteDirname(elmWatchJsonPath);
  if (commandName === ELM_WATCH_NODE) {
    const worker = postprocessWorkerPool.getOrCreateAvailableWorker();
    return {
      promise: worker.postprocess({
        cwd,
        code: code.toString("utf8"),
        targetName: output.targetName,
        compilationMode,
        runMode,
        userArgs
      }),
      kill: () => worker.terminate()
    };
  }
  const command = {
    command: commandName,
    args: [...userArgs, output.targetName, compilationMode, runMode],
    options: { cwd, env },
    stdin: code
  };
  const { promise, kill } = spawn2(command);
  const handleSpawnResult = (spawnResult) => {
    switch (spawnResult.tag) {
      case "CommandNotFoundError":
      case "OtherSpawnError":
        return spawnResult;
      // This is covered on macOS and Windows, but not Linux.
      /* v8 ignore start */
      case "StdinWriteError":
        return {
          tag: "PostprocessStdinWriteError",
          error: spawnResult.error,
          command: spawnResult.command
        };
      /* v8 ignore stop */
      case "Killed":
        return { tag: "Killed" };
      case "Exit": {
        const { exitReason: exitReason2 } = spawnResult;
        if (!(exitReason2.tag === "ExitCode" && exitReason2.exitCode === 0)) {
          const stdout = spawnResult.stdout.toString("utf8");
          const stderr = spawnResult.stderr.toString("utf8");
          return {
            tag: "PostprocessNonZeroExit",
            exitReason: exitReason2,
            stdout,
            stderr,
            command
          };
        }
        return { tag: "Success", code: spawnResult.stdout };
      }
    }
  };
  return {
    promise: promise.then(handleSpawnResult),
    kill: () => {
      kill();
      return Promise.resolve();
    }
  };
}
var PostprocessWorkerPool = class {
  constructor(onUnexpectedError) {
    this.onUnexpectedError = onUnexpectedError;
    this.workers = /* @__PURE__ */ new Set();
    this.calculateMax = () => Infinity;
  }
  getSize() {
    return this.workers.size;
  }
  setCalculateMax(calculateMax) {
    this.calculateMax = calculateMax;
  }
  getOrCreateAvailableWorker() {
    const existingWorker = Array.from(this.workers).find(
      (worker) => worker.isIdle()
    );
    if (existingWorker === void 0) {
      const newWorker = new PostprocessWorker(
        this.onUnexpectedError,
        () => {
          this.limit().catch(this.onUnexpectedError);
        },
        (worker) => {
          this.workers.delete(worker);
        }
      );
      this.workers.add(newWorker);
      return newWorker;
    } else {
      return existingWorker;
    }
  }
  async limit() {
    const idle = Array.from(this.workers).filter((worker) => worker.isIdle());
    const toKill = this.workers.size - this.calculateMax();
    if (toKill > 0) {
      await Promise.all(
        idle.slice(-toKill).map((worker) => worker.terminate())
      );
    }
    return toKill;
  }
  async terminate() {
    await Promise.all(
      Array.from(this.workers).map((worker) => worker.terminate())
    );
  }
};
var PostprocessWorker = class {
  constructor(onUnexpectedError, onIdle, onTerminated) {
    this.onUnexpectedError = onUnexpectedError;
    this.onIdle = onIdle;
    this.onTerminated = onTerminated;
    this.worker = new import_worker_threads.Worker(path5.join(__dirname, "PostprocessWorker.js"), {
      stdout: true,
      stderr: true
    });
    this.status = { tag: "Idle" };
    const stdout = [];
    const stderr = [];
    this.worker.stdout.on("data", (chunk) => {
      stdout.push(chunk);
    });
    this.worker.stderr.on("data", (chunk) => {
      stderr.push(chunk);
    });
    this.worker.on("error", (error) => {
      if (this.status.tag !== "Terminated") {
        this.status = { tag: "Terminated" };
        this.onTerminated(this);
        this.onUnexpectedError(error);
      }
    });
    this.worker.on("messageerror", (error) => {
      if (this.status.tag !== "Terminated") {
        this.status = { tag: "Terminated" };
        this.onTerminated(this);
        this.onUnexpectedError(error);
      }
    });
    this.worker.on("exit", (exitCode) => {
      if (this.status.tag !== "Terminated") {
        this.status = { tag: "Terminated" };
        this.onTerminated(this);
        this.onUnexpectedError(
          new Error(
            `PostprocessWorker unexpectedly exited, with exit code ${exitCode}.`
          )
        );
      }
    });
    this.worker.on("message", (message) => {
      switch (message.tag) {
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        case "PostprocessDone":
          switch (this.status.tag) {
            /* v8 ignore start */
            case "Idle":
              this.terminate().catch(this.onUnexpectedError);
              this.onUnexpectedError(
                new Error(
                  `PostprocessWorker received a ${quote(
                    message.tag
                  )} message from the worker. This should only happen when "Busy" but the status is "Idle".`
                )
              );
              break;
            /* v8 ignore stop */
            case "Busy":
              switch (message.result.tag) {
                case "Resolve": {
                  const result = message.result.value;
                  this.status.resolve(
                    "stdout" in result ? {
                      ...result,
                      stdout: Buffer.concat(stdout).toString("utf8"),
                      stderr: Buffer.concat(stderr).toString("utf8")
                    } : result
                  );
                  break;
                }
                /* v8 ignore start */
                case "Reject":
                  this.status.reject(toError(message.result.error));
                  break;
              }
              this.status = { tag: "Idle" };
              this.onIdle(this);
              break;
            /* v8 ignore start */
            case "Terminated":
              break;
          }
          stdout.length = 0;
          stderr.length = 0;
      }
    });
  }
  postMessage(message) {
    this.worker.postMessage(message);
  }
  isIdle() {
    return this.status.tag === "Idle";
  }
  async postprocess(args) {
    switch (this.status.tag) {
      case "Idle":
        return new Promise((resolve3, reject) => {
          this.status = { tag: "Busy", resolve: resolve3, reject };
          this.postMessage({ tag: "StartPostprocess", args });
        });
      /* v8 ignore start */
      case "Busy":
      case "Terminated":
        throw new Error(
          `Cannot call PostprocessWorker#postprocess because \`this.status === ${Codec10.JSON.stringify(
            Codec10.unknown,
            this.status
          )}\` instead of the expected "Idle".`
        );
    }
  }
  async terminate() {
    switch (this.status.tag) {
      case "Idle":
        this.status = { tag: "Terminated" };
        this.onTerminated(this);
        await this.worker.terminate();
        break;
      case "Busy": {
        const { resolve: resolve3 } = this.status;
        this.status = { tag: "Terminated" };
        this.onTerminated(this);
        await this.worker.terminate();
        resolve3({ tag: "Killed" });
        break;
      }
      /* v8 ignore start */
      case "Terminated":
    }
  }
};

// src/SpawnElm.ts
var fs4 = require("fs");
var os2 = require("os");
var path6 = require("path");
var Codec12 = require("tiny-decoders");

// src/ElmMakeError.ts
var Codec11 = require("tiny-decoders");
var Color = Codec11.primitiveUnion([
  "red",
  "RED",
  "magenta",
  "MAGENTA",
  "yellow",
  "YELLOW",
  "green",
  "GREEN",
  "cyan",
  "CYAN",
  "blue",
  "BLUE",
  "black",
  "BLACK",
  "white",
  "WHITE"
]);
var StyledText = Codec11.fields({
  bold: Codec11.boolean,
  underline: Codec11.boolean,
  color: Codec11.nullOr(Color),
  string: Codec11.string
});
var MessageChunk = Codec11.flatMap(Codec11.multi(["string", "object"]), {
  decoder: (value) => {
    switch (value.type) {
      case "string":
        return {
          tag: "Valid",
          value: value.value
        };
      case "object":
        return StyledText.decoder(value.value);
    }
  },
  encoder: (value) => typeof value === "string" ? {
    type: "string",
    value
  } : {
    type: "object",
    value: StyledText.encoder(value)
  }
});
var Position = Codec11.fields({
  line: Codec11.number,
  column: Codec11.number
});
var Region = Codec11.fields({
  start: Position,
  end: Position
});
var Problem = Codec11.fields({
  title: Codec11.string,
  region: Region,
  message: Codec11.array(MessageChunk)
});
var CompileError = Codec11.fields({
  // https://github.com/elm/compiler/blob/94715a520f499591ac6901c8c822bc87cd1af24f/compiler/src/Reporting/Error.hs#L42
  path: AbsolutePath,
  name: Codec11.string,
  problems: NonEmptyArray(Problem)
});
var GeneralErrorPath = Codec11.nullOr(Codec11.primitiveUnion(["elm.json"]));
var ElmMakeError = Codec11.taggedUnion("type", [
  {
    type: Codec11.tag("error"),
    // `Nothing` and `Just "elm.json"` are the only values I’ve found in the compiler code base.
    path: GeneralErrorPath,
    title: Codec11.string,
    message: Codec11.array(MessageChunk)
  },
  {
    type: Codec11.tag("compile-errors"),
    errors: NonEmptyArray(CompileError)
  }
]);

// src/SpawnElm.ts
function make({
  elmJsonPath,
  compilationMode,
  inputs,
  outputPath,
  env,
  getNow
}) {
  const cwd = absoluteDirname(elmJsonPath);
  const command = {
    command: "elm",
    args: [
      "make",
      "--report=json",
      ...maybeToArray(compilationModeToArg(compilationMode)),
      `--output=${outputPathToAbsoluteString(cwd, outputPath)}`,
      // Use relative paths because:
      // - Windows has a maximum command length. See: https://github.com/lydell/elm-watch/issues/86
      // - It looks nicer in error messages (the printed commands are much shorter).
      ...inputs.map((inputPath) => path6.relative(cwd, inputPath.theInputPath))
    ],
    options: {
      cwd,
      env
    }
  };
  const { promise, kill } = spawn2(command);
  const handleSpawnResult = (spawnResult) => {
    switch (spawnResult.tag) {
      /* v8 ignore start */
      case "CommandNotFoundError":
        return { tag: "ElmNotFoundError", command };
      /* v8 ignore stop */
      /* v8 ignore start */
      case "OtherSpawnError":
      case "StdinWriteError":
        return {
          tag: "OtherSpawnError",
          error: spawnResult.error,
          command: spawnResult.command
        };
      /* v8 ignore stop */
      case "Killed":
        return { tag: "Killed" };
      case "Exit": {
        const { exitReason: exitReason2 } = spawnResult;
        const stdout = spawnResult.stdout.toString("utf8");
        const stderr = spawnResult.stderr.toString("utf8");
        const unexpectedElmMakeOutput2 = {
          tag: "UnexpectedElmMakeOutput",
          exitReason: exitReason2,
          stdout,
          stderr,
          command
        };
        return exitReason2.tag === "ExitCode" && exitReason2.exitCode === 0 && stdout === "" && stderr === "" ? { tag: "Success" } : exitReason2.tag === "ExitCode" && exitReason2.exitCode === 1 && stdout === "" ? parsePotentialElmMakeJson(command, stderr) ?? unexpectedElmMakeOutput2 : unexpectedElmMakeOutput2;
      }
    }
  };
  const startTime = getNow().getTime();
  return {
    promise: promise.then(handleSpawnResult),
    kill: ({ force }) => {
      if (force) {
        kill();
      } else {
        delayKill(promise, startTime, getNow, env, kill);
      }
    }
  };
}
function delayKill(promise, startTime, getNow, env, kill) {
  const timeout = silentlyReadIntEnvValue(
    env[__ELM_WATCH_ELM_TIMEOUT_MS],
    1e4
  );
  const elapsed = getNow().getTime() - startTime;
  const timeoutId = setTimeout(kill, Math.max(0, timeout - elapsed));
  void promise.finally(() => {
    clearTimeout(timeoutId);
  });
}
function compilationModeToArg(compilationMode) {
  switch (compilationMode) {
    case "standard":
      return void 0;
    case "debug":
      return "--debug";
    case "optimize":
      return "--optimize";
  }
}
function outputPathToAbsoluteString(cwd, outputPath) {
  switch (outputPath.tag) {
    case "OutputPath":
      return path6.relative(
        cwd,
        outputPath.writeToTemporaryDir ? outputPath.temporaryOutputPath : outputPath.theOutputPath
      );
    case "NullOutputPath":
      return "/dev/null";
  }
}
function maybeToArray(arg) {
  return arg === void 0 ? [] : [arg];
}
function parsePotentialElmMakeJson(command, stderr) {
  if (!stderr.endsWith("}")) {
    const errorIndex = stderr.lastIndexOf("elm: ");
    if (errorIndex !== -1) {
      return {
        tag: "ElmMakeCrashError",
        beforeError: stderr.startsWith("{") ? { tag: "Json", length: errorIndex } : { tag: "Text", text: stderr.slice(0, errorIndex) },
        error: stderr.slice(errorIndex),
        command
      };
    }
  }
  const match = elmStuffErrorMessagePrefixRegex.exec(stderr);
  const elmStuffError = match?.[0];
  const potentialJson = elmStuffError === void 0 ? stderr : stderr.slice(elmStuffError.length);
  return potentialJson.startsWith("{") ? parseActualElmMakeJson(command, potentialJson, elmStuffError?.trim()) : void 0;
}
function parseActualElmMakeJson(command, jsonString, extraError) {
  const parsed = Codec12.JSON.parse(
    ElmMakeError,
    jsonString.replace(/\t/g, "\\t")
  );
  switch (parsed.tag) {
    case "DecoderError":
      return {
        tag: "ElmMakeJsonParseError",
        error: parsed.error,
        errorFilePath: tryWriteErrorFile({
          cwd: command.options.cwd,
          name: "ElmMakeJsonParseError",
          content: toPlainString(
            elmMakeJsonParseError(
              { tag: "NoLocation" },
              parsed.error,
              { tag: "ErrorFileBadContent", content: jsonString },
              command
            )
          ),
          hash: jsonString
        }),
        command
      };
    case "Valid":
      return {
        tag: "ElmMakeError",
        error: parsed.value,
        extraError
      };
  }
}
var elmJsonErrorMessageRegex = /^-- (.+) -+( elm\.json)?\r?\n([^]+)$/;
var elmStuffErrorMessagePrefixRegex = /^\+-+\r?\n(?:\|.*\r?\n)+\+-+\r?\n\r?\n/;
function install({
  elmJsonPath,
  env,
  getNow
}) {
  const dummy = absolutePathFromString(
    markAsAbsolutePath(env[__ELM_WATCH_TMP_DIR] ?? os2.tmpdir()),
    "ElmWatchDummy.elm"
  );
  try {
    fs4.writeFileSync(dummy, elmWatchDummy());
  } catch (unknownError) {
    const error = toError(unknownError);
    return {
      promise: Promise.resolve({
        tag: "CreatingDummyFailed",
        error
      }),
      kill: (
        /* v8 ignore start */
        () => {
        }
      )
      /* v8 ignore stop */
    };
  }
  const command = {
    command: "elm",
    // Don’t use `--report=json` here, because then Elm won’t print downloading
    // of packages. We unfortunately lose colors this way, but package download
    // errors aren’t very colorful anyway.
    args: ["make", `--output=/dev/null`, dummy],
    options: {
      cwd: absoluteDirname(elmJsonPath),
      env
    }
  };
  const { promise, kill } = spawn2(command);
  const handleSpawnResult = (spawnResult) => {
    switch (spawnResult.tag) {
      case "CommandNotFoundError":
        return { tag: "ElmNotFoundError", command };
      /* v8 ignore start */
      case "OtherSpawnError":
      case "StdinWriteError":
        return {
          tag: "OtherSpawnError",
          error: spawnResult.error,
          command: spawnResult.command
        };
      /* v8 ignore stop */
      case "Killed":
        return { tag: "Killed" };
      case "Exit": {
        const { exitReason: exitReason2 } = spawnResult;
        const stdout = spawnResult.stdout.toString("utf8");
        const stderr = spawnResult.stderr.toString("utf8");
        if (exitReason2.tag === "ExitCode" && exitReason2.exitCode === 0 && stderr === "") {
          return {
            tag: "Success",
            elmInstallOutput: stdout.split(/\r?\n|\r/).filter((line) => line.startsWith("  ")).map((line) => ` ${line}`).join("\n").trimEnd()
          };
        }
        if (elmStuffErrorMessagePrefixRegex.test(stderr)) {
          return { tag: "ElmStuffError" };
        }
        const match = elmJsonErrorMessageRegex.exec(stderr);
        if (exitReason2.tag === "ExitCode" && exitReason2.exitCode === 1 && // Don’t bother checking stdout. Elm likes to print
        // "Dependencies ready!" even on failure.
        match !== null) {
          const [, title, elmJson2, message] = match;
          if (elmJson2 !== void 0) {
            return { tag: "ElmJsonError" };
          }
          if (title !== void 0 && message !== void 0) {
            return {
              tag: "ElmInstallError",
              title,
              message
            };
          }
        }
        return {
          tag: "UnexpectedElmInstallOutput",
          exitReason: exitReason2,
          stdout,
          stderr,
          command
        };
      }
    }
  };
  const startTime = getNow().getTime();
  return {
    promise: promise.then(handleSpawnResult),
    kill: ({ force }) => {
      if (force) {
        kill();
      } else {
        delayKill(promise, startTime, getNow, env, kill);
      }
    }
  };
}
function elmWatchDummy() {
  return `
module ElmWatchDummy exposing (dummy)


dummy : ()
dummy =
    ()
  `.trim();
}

// src/Compile.ts
function installDependencies(env, logger, getNow, project) {
  let currentKill = void 0;
  const loadingMessageDelay = silentlyReadIntEnvValue(
    env[__ELM_WATCH_LOADING_MESSAGE_DELAY],
    100
  );
  const printStatusLineHelper = (emojiName, message, nonFancy) => printStatusLine({
    maxWidth: logger.config.columns,
    fancy: logger.config.fancy,
    isTTY: logger.config.isTTY,
    emojiName,
    string: logger.config.fancy ? message : `${message}: ${nonFancy}`
  });
  const continuation = async () => {
    const elmJsonsArray = Array.from(project.elmJsons);
    for (const [index, [elmJsonPath]] of elmJsonsArray.entries()) {
      const message = `Dependencies${index === 0 ? "" : ` (${index + 1}/${elmJsonsArray.length})`}`;
      const loadingMessage = printStatusLineHelper(
        "Busy",
        message,
        "in progress"
      );
      let didWriteLoadingMessage = false;
      const timeoutId = setTimeout(() => {
        logger.write(loadingMessage);
        didWriteLoadingMessage = true;
      }, loadingMessageDelay);
      const clearLoadingMessage = () => {
        if (didWriteLoadingMessage) {
          logger.moveCursor(0, -1);
          logger.clearLine(0);
        }
      };
      const onError = (error) => {
        clearLoadingMessage();
        logger.write(printStatusLineHelper("Error", message, "error"));
        logger.write("");
        logger.errorTemplate(error);
        return { tag: "Error" };
      };
      const { promise, kill } = install({ elmJsonPath, env, getNow });
      currentKill = kill;
      const result = await promise.finally(() => {
        currentKill = void 0;
      });
      clearTimeout(timeoutId);
      switch (result.tag) {
        // If the elm.json is invalid or elm-stuff/ is corrupted we can just
        // ignore that and let the “real” compilation later catch it. This way we
        // get colored error messages.
        case "ElmJsonError":
        case "ElmStuffError":
          if (didWriteLoadingMessage) {
            clearLoadingMessage();
            logger.write(printStatusLineHelper("Skipped", message, "skipped"));
          }
          break;
        case "Killed":
          if (didWriteLoadingMessage) {
            clearLoadingMessage();
            logger.write(printStatusLineHelper("Busy", message, "interrupted"));
          }
          return { tag: "Killed" };
        case "Success": {
          const gotOutput = result.elmInstallOutput !== "";
          if (didWriteLoadingMessage || gotOutput) {
            clearLoadingMessage();
            logger.write(printStatusLineHelper("Success", message, "success"));
          }
          if (gotOutput) {
            logger.write(result.elmInstallOutput);
          }
          break;
        }
        case "CreatingDummyFailed":
          return onError(creatingDummyFailed(elmJsonPath, result.error));
        case "ElmNotFoundError":
          return onError(
            elmNotFoundError(
              { tag: "ElmJsonPath", theElmJsonPath: elmJsonPath },
              result.command
            )
          );
        /* v8 ignore start */
        case "OtherSpawnError":
          return onError(
            otherSpawnError(
              { tag: "ElmJsonPath", theElmJsonPath: elmJsonPath },
              result.error,
              result.command
            )
          );
        /* v8 ignore stop */
        case "ElmInstallError":
          return onError(
            elmInstallError(elmJsonPath, result.title, result.message)
          );
        case "UnexpectedElmInstallOutput":
          return onError(
            unexpectedElmInstallOutput(
              elmJsonPath,
              result.exitReason,
              result.stdout,
              result.stderr,
              result.command
            )
          );
      }
    }
    return { tag: "Success" };
  };
  return {
    promise: continuation(),
    kill: ({ force }) => {
      if (currentKill !== void 0) {
        currentKill({ force });
      }
    }
  };
}
function getOutputActions({
  project,
  runMode,
  includeInterrupted,
  prioritizedOutputs
}) {
  let index = 0;
  let numExecuting = 0;
  let numInterrupted = 0;
  let numErrors = 0;
  const elmMakeActions = [];
  const elmMakeTypecheckOnlyActions = [];
  const postprocessActions = [];
  const outputsWithoutAction = [];
  const busyElmJsons = /* @__PURE__ */ new Set();
  for (const [elmJsonPath, outputs] of project.elmJsons) {
    const typecheckOnly = [];
    for (const [outputPath, outputState] of outputs) {
      const output = {
        index,
        elmJsonPath,
        outputPath,
        outputState
      };
      index++;
      const priority = prioritizedOutputs === "AllEqualPriority" ? 0 : prioritizedOutputs.get(outputPath.targetName);
      const needsElm = (source) => {
        if (priority !== void 0) {
          elmMakeActions.push({
            tag: "NeedsElmMake",
            elmJsonPath,
            output,
            source,
            priority
          });
        } else {
          typecheckOnly.push({ output, source });
        }
      };
      switch (outputState.status.tag) {
        case "ElmMake":
        case "ElmMakeTypecheckOnly":
          numExecuting++;
          outputsWithoutAction.push(output);
          busyElmJsons.add(elmJsonPath);
          break;
        case "Postprocess":
          numExecuting++;
          outputsWithoutAction.push(output);
          break;
        case "QueuedForElmMake":
          needsElm("Queued");
          break;
        case "QueuedForPostprocess":
          postprocessActions.push({
            tag: "NeedsPostprocess",
            output,
            postprocessArray: outputState.status.postprocessArray,
            priority: (
              /* v8 ignore next */
              priority ?? 0
            ),
            code: outputState.status.code,
            elmCompiledTimestamp: outputState.status.elmCompiledTimestamp,
            recordFields: outputState.status.recordFields
          });
          break;
        case "Interrupted":
          numInterrupted++;
          if (includeInterrupted) {
            needsElm("Dirty");
          } else {
            outputsWithoutAction.push(output);
          }
          break;
        case "Success":
        case "NotWrittenToDisk":
          if (outputState.dirty) {
            needsElm("Dirty");
          } else {
            outputsWithoutAction.push(output);
          }
          break;
        default: {
          const _ = outputState.status;
          numErrors++;
          if (outputState.dirty) {
            needsElm("Dirty");
          } else {
            outputsWithoutAction.push(output);
          }
          break;
        }
      }
    }
    if (isNonEmptyArray(typecheckOnly)) {
      elmMakeTypecheckOnlyActions.push({
        tag: "NeedsElmMakeTypecheckOnly",
        elmJsonPath,
        outputs: typecheckOnly
      });
    }
  }
  const prioritizedActions = prioritizeActions(
    runMode,
    elmMakeActions,
    elmMakeTypecheckOnlyActions,
    postprocessActions
  );
  const actions = [];
  const queueActions = [];
  const threadsLeft = Math.max(0, project.maxParallel - numExecuting);
  for (const action of prioritizedActions) {
    switch (action.tag) {
      case "NeedsElmMake":
        if (actions.length < threadsLeft && !busyElmJsons.has(action.elmJsonPath)) {
          busyElmJsons.add(action.elmJsonPath);
          actions.push(action);
        } else {
          switch (action.source) {
            case "Dirty":
              queueActions.push({
                tag: "QueueForElmMake",
                output: action.output
              });
              break;
            case "Queued":
              outputsWithoutAction.push(action.output);
              break;
          }
        }
        break;
      case "NeedsElmMakeTypecheckOnly":
        if (actions.length < threadsLeft && !busyElmJsons.has(action.elmJsonPath)) {
          busyElmJsons.add(action.elmJsonPath);
          actions.push(action);
        } else {
          for (const { output, source } of action.outputs) {
            switch (source) {
              case "Dirty":
                queueActions.push({
                  tag: "QueueForElmMake",
                  output
                });
                break;
              case "Queued":
                outputsWithoutAction.push(output);
                break;
            }
          }
        }
        break;
      case "NeedsPostprocess":
        if (actions.length < threadsLeft) {
          actions.push(action);
        } else {
          outputsWithoutAction.push(action.output);
        }
        break;
    }
  }
  return {
    total: index,
    numExecuting,
    numInterrupted,
    numErrors,
    actions: [...actions, ...queueActions],
    outputsWithoutAction
  };
}
function prioritizeActions(runMode, elmMakeActions, elmMakeTypecheckOnlyActions, postprocessActions) {
  switch (runMode) {
    // In `make` mode, you want to find type errors as quickly as possible (the
    // most likely CI failure). Don’t let slow postprocessing delay that.
    // All outputs have the same priority in `make` mode so don’t bother sorting.
    case "make":
      return [
        ...elmMakeActions,
        ...elmMakeTypecheckOnlyActions,
        ...postprocessActions
      ];
    // In `hot` mode, try to finish each output as fast as possible, rather than
    // make all of them “evenly slow”.
    case "hot":
      return [
        ...sortByPriority(postprocessActions),
        ...sortByPriority(elmMakeActions),
        ...elmMakeTypecheckOnlyActions
      ];
  }
}
function sortByPriority(array4) {
  return array4.slice().sort((a, b) => b.priority - a.priority);
}
async function handleOutputAction({
  env,
  logger,
  getNow,
  runMode,
  elmWatchJsonPath,
  total,
  action,
  postprocess,
  postprocessWorkerPool
}) {
  switch (action.tag) {
    case "NeedsElmMake":
      return compileOneOutput({
        env,
        logger,
        getNow,
        runMode,
        total,
        ...action.output,
        postprocess
      });
    case "NeedsElmMakeTypecheckOnly":
      switch (runMode.tag) {
        /* v8 ignore start */
        case "make":
          throw new Error(
            `Got NeedsElmMakeTypecheckOnly in \`make\` mode!
${Codec13.JSON.stringify(
              Codec13.unknown,
              action,
              2
            )}`
          );
        /* v8 ignore stop */
        case "hot":
          await typecheck({
            env,
            logger,
            getNow,
            runMode: runMode.tag,
            elmJsonPath: action.elmJsonPath,
            outputs: mapNonEmptyArray(action.outputs, ({ output }) => output),
            total,
            webSocketPort: runMode.webSocketPort,
            webSocketToken: runMode.webSocketToken
          });
          return { tag: "Nothing" };
      }
    case "NeedsPostprocess":
      return postprocessHelper({
        env,
        logger,
        runMode,
        elmWatchJsonPath,
        total,
        ...action.output,
        postprocessArray: action.postprocessArray,
        postprocessWorkerPool,
        code: action.code,
        elmCompiledTimestamp: action.elmCompiledTimestamp,
        recordFields: action.recordFields
      });
    case "QueueForElmMake":
      action.output.outputState.setStatus({ tag: "QueuedForElmMake" });
      updateStatusLine({
        logger,
        runMode: runMode.tag,
        total,
        ...action.output
      });
      return { tag: "Nothing" };
  }
}
async function compileOneOutput({
  env,
  logger,
  getNow,
  runMode,
  elmJsonPath,
  outputPath,
  outputState,
  index,
  total,
  postprocess
}) {
  const startTimestamp = getNow().getTime();
  const updateStatusLineHelper = () => {
    updateStatusLine({
      logger,
      runMode: runMode.tag,
      outputPath,
      outputState,
      index,
      total
    });
  };
  outputState.dirty = false;
  const { promise, kill } = make({
    elmJsonPath,
    compilationMode: outputState.compilationMode,
    inputs: outputState.inputs,
    outputPath: {
      ...outputPath,
      writeToTemporaryDir: !(runMode.tag === "make" && postprocess.tag === "NoPostprocess")
    },
    env,
    getNow
  });
  const outputStatus = {
    tag: "ElmMake",
    compilationMode: outputState.compilationMode,
    // These are updated as we go.
    elmDurationMs: -1,
    walkerDurationMs: -1,
    injectDurationMs: -1,
    kill
  };
  outputState.setStatus(outputStatus);
  updateStatusLineHelper();
  const [elmMakeResult, allRelatedElmFilePathsResult] = await Promise.all([
    promise.then((result) => {
      outputStatus.elmDurationMs = getNow().getTime() - startTimestamp;
      return result;
    }),
    Promise.resolve().then(() => {
      switch (runMode.tag) {
        case "make":
          return {
            tag: "Success",
            allRelatedElmFilePaths: outputState.allRelatedElmFilePaths
          };
        case "hot": {
          const result = getAllRelatedElmFilePaths(
            elmJsonPath,
            outputState.inputs
          );
          outputStatus.walkerDurationMs = getNow().getTime() - startTimestamp;
          return result;
        }
      }
    })
  ]);
  if (outputState.dirty || elmMakeResult.tag === "Killed") {
    outputState.setStatus({ tag: "Interrupted" });
    updateStatusLineHelper();
    return { tag: "Nothing" };
  }
  outputState.allRelatedElmFilePaths = allRelatedElmFilePathsWithFallback(
    allRelatedElmFilePathsResult,
    outputState
  );
  const combinedResult = combineResults(
    elmMakeResult,
    allRelatedElmFilePathsResult
  );
  switch (combinedResult.tag) {
    case "elm make success + walker success":
      return onCompileSuccess(
        logger.config,
        getNow,
        updateStatusLineHelper,
        runMode,
        elmJsonPath,
        outputPath,
        outputState,
        outputStatus,
        postprocess
      );
    case "elm make success + walker failure":
      outputState.setStatus(combinedResult.walkerError);
      updateStatusLineHelper();
      return {
        tag: "CompileError",
        elmJsonPath,
        outputPath,
        outputState
      };
    case "elm make failure + walker success":
      outputState.setStatus(combinedResult.elmMakeError);
      updateStatusLineHelper();
      return {
        tag: "CompileError",
        elmJsonPath,
        outputPath,
        outputState
      };
    case "elm make failure + walker failure":
      outputState.setStatus(combinedResult.elmMakeError);
      updateStatusLineHelper();
      return {
        tag: "CompileError",
        elmJsonPath,
        outputPath,
        outputState
      };
  }
}
function onCompileSuccess(loggerConfig, getNow, updateStatusLineHelper, runMode, elmJsonPath, outputPath, outputState, outputStatus, postprocess) {
  const elmCompiledTimestamp = getNow().getTime();
  switch (runMode.tag) {
    case "make":
      switch (postprocess.tag) {
        case "NoPostprocess": {
          let fileSize;
          try {
            fileSize = fs5.statSync(outputPath.theOutputPath).size;
          } catch (unknownError) {
            const error = toError(unknownError);
            outputState.setStatus({
              tag: "ReadOutputError",
              error,
              triedPath: outputPath.theOutputPath
            });
            updateStatusLineHelper();
            return {
              tag: "CompileError",
              elmJsonPath,
              outputPath,
              outputState
            };
          }
          outputState.setStatus({
            tag: "Success",
            elmFileSize: fileSize,
            postprocessFileSize: fileSize,
            elmCompiledTimestamp
          });
          updateStatusLineHelper();
          return { tag: "Nothing" };
        }
        case "Postprocess": {
          let buffer;
          try {
            buffer = fs5.readFileSync(outputPath.temporaryOutputPath);
          } catch (unknownError) {
            const error = toError(unknownError);
            outputState.setStatus({
              tag: "ReadOutputError",
              error,
              triedPath: outputPath.temporaryOutputPath
            });
            updateStatusLineHelper();
            return {
              tag: "CompileError",
              elmJsonPath,
              outputPath,
              outputState
            };
          }
          outputState.setStatus({
            tag: "QueuedForPostprocess",
            postprocessArray: postprocess.postprocessArray,
            code: buffer,
            elmCompiledTimestamp,
            recordFields: void 0
          });
          updateStatusLineHelper();
          return { tag: "Nothing" };
        }
      }
    case "hot": {
      let code;
      try {
        code = fs5.readFileSync(outputPath.temporaryOutputPath, "utf8");
      } catch (unknownError) {
        const error = toError(unknownError);
        outputState.setStatus({
          tag: "ReadOutputError",
          error,
          triedPath: outputPath.temporaryOutputPath
        });
        updateStatusLineHelper();
        return {
          tag: "CompileError",
          elmJsonPath,
          outputPath,
          outputState
        };
      }
      const recordFields = getRecordFields(
        outputState.compilationMode,
        code
      );
      const newCode = inject(
        outputState.compilationMode,
        code,
        outputPath.targetName
      );
      outputStatus.injectDurationMs = getNow().getTime() - elmCompiledTimestamp;
      switch (postprocess.tag) {
        case "NoPostprocess": {
          try {
            fs5.mkdirSync(absoluteDirname(outputPath.theOutputPath), {
              recursive: true
            });
            fs5.writeFileSync(
              outputPath.theOutputPath,
              // This will inject `elmCompiledTimestamp` into the built
              // code, which is later used to detect if recompilations are
              // needed or not. Note: This needs to be the timestamp of
              // when Elm finished compiling, not when postprocessing
              // finished. That’s because we haven’t done the
              // postprocessing yet, but have to inject before that. So
              // we’re storing the timestamp when Elm finished rather
              // than when the entire process was finished.
              clientCode(
                outputPath,
                elmCompiledTimestamp,
                outputState.compilationMode,
                outputState.browserUiPosition,
                runMode.webSocketPort,
                runMode.webSocketToken,
                loggerConfig.debug
              ) + newCode
            );
          } catch (unknownError) {
            const error = toError(unknownError);
            outputState.setStatus({
              tag: "WriteOutputError",
              error,
              reasonForWriting: "InjectWebSocketClient"
            });
            updateStatusLineHelper();
            return {
              tag: "CompileError",
              elmJsonPath,
              outputPath,
              outputState
            };
          }
          const recordFieldsChanged2 = recordFieldsChanged(
            outputState.recordFields,
            recordFields
          );
          const fileSize = Buffer.byteLength(newCode);
          outputState.recordFields = recordFields;
          outputState.setStatus({
            tag: "Success",
            elmFileSize: fileSize,
            postprocessFileSize: fileSize,
            elmCompiledTimestamp
          });
          updateStatusLineHelper();
          return recordFieldsChanged2 ? {
            tag: "FullyCompiledJSButRecordFieldsChanged",
            outputPath
          } : {
            tag: "FullyCompiledJS",
            outputPath,
            outputState,
            code: newCode,
            elmCompiledTimestamp
          };
        }
        case "Postprocess": {
          outputState.setStatus({
            tag: "QueuedForPostprocess",
            postprocessArray: postprocess.postprocessArray,
            code: newCode,
            elmCompiledTimestamp,
            recordFields
          });
          updateStatusLineHelper();
          return { tag: "Nothing" };
        }
      }
    }
  }
}
function needsToWriteProxyFile(outputPath, versionedIdentifier2) {
  let handle;
  try {
    handle = fs5.openSync(outputPath, "r");
  } catch (unknownError) {
    const error = toError(unknownError);
    return error.code === "ENOENT" ? { tag: "Needed" } : { tag: "ReadError", error };
  }
  const buffer = Buffer.alloc(versionedIdentifier2.byteLength);
  try {
    fs5.readSync(handle, buffer);
  } catch (unknownError) {
    const error = toError(unknownError);
    return { tag: "ReadError", error };
  }
  return buffer.equals(versionedIdentifier2) ? { tag: "NotNeeded" } : { tag: "Needed" };
}
async function postprocessHelper({
  env,
  logger,
  runMode,
  elmWatchJsonPath,
  elmJsonPath,
  outputPath,
  outputState,
  index,
  total,
  postprocessArray,
  postprocessWorkerPool,
  code,
  elmCompiledTimestamp,
  recordFields
}) {
  const updateStatusLineHelper = () => {
    updateStatusLine({
      logger,
      runMode: runMode.tag,
      outputPath,
      outputState,
      index,
      total
    });
  };
  const { promise, kill } = runPostprocess({
    env,
    elmWatchJsonPath,
    compilationMode: outputState.compilationMode,
    runMode: runMode.tag,
    outputPath,
    postprocessArray,
    postprocessWorkerPool,
    code
  });
  outputState.setStatus({ tag: "Postprocess", kill });
  updateStatusLineHelper();
  const postprocessResult = await promise;
  switch (postprocessResult.tag) {
    case "Killed":
      outputState.dirty = true;
      outputState.setStatus({ tag: "Interrupted" });
      updateStatusLineHelper();
      return { tag: "Nothing" };
    case "Success": {
      try {
        fs5.mkdirSync(absoluteDirname(outputPath.theOutputPath), {
          recursive: true
        });
        switch (runMode.tag) {
          case "make":
            fs5.writeFileSync(outputPath.theOutputPath, postprocessResult.code);
            break;
          case "hot": {
            const clientCode2 = clientCode(
              outputPath,
              elmCompiledTimestamp,
              outputState.compilationMode,
              outputState.browserUiPosition,
              runMode.webSocketPort,
              runMode.webSocketToken,
              logger.config.debug
            );
            fs5.writeFileSync(
              outputPath.theOutputPath,
              typeof postprocessResult.code === "string" ? clientCode2 + postprocessResult.code : Buffer.concat([
                Buffer.from(clientCode2),
                postprocessResult.code
              ])
            );
            break;
          }
        }
      } catch (unknownError) {
        const error = toError(unknownError);
        outputState.setStatus({
          tag: "WriteOutputError",
          error,
          reasonForWriting: "Postprocess"
        });
        updateStatusLineHelper();
        return {
          tag: "CompileError",
          elmJsonPath,
          outputPath,
          outputState
        };
      }
      const recordFieldsChanged2 = recordFieldsChanged(
        outputState.recordFields,
        recordFields
      );
      outputState.recordFields = recordFields;
      outputState.setStatus({
        tag: "Success",
        elmFileSize: Buffer.byteLength(code),
        postprocessFileSize: Buffer.byteLength(postprocessResult.code),
        elmCompiledTimestamp
      });
      updateStatusLineHelper();
      return recordFieldsChanged2 ? {
        tag: "FullyCompiledJSButRecordFieldsChanged",
        outputPath
      } : {
        tag: "FullyCompiledJS",
        outputPath,
        outputState,
        code: postprocessResult.code,
        elmCompiledTimestamp
      };
    }
    default:
      outputState.setStatus(postprocessResult);
      updateStatusLineHelper();
      return {
        tag: "CompileError",
        elmJsonPath,
        outputPath,
        outputState
      };
  }
}
async function typecheck({
  env,
  logger,
  getNow,
  runMode,
  elmJsonPath,
  outputs,
  total,
  webSocketPort,
  webSocketToken
}) {
  const startTimestamp = getNow().getTime();
  const outputsWithStatus = [];
  const { promise, kill } = make({
    elmJsonPath,
    compilationMode: "standard",
    // Mentioning the same input twice is an error according to `elm make`.
    // It even resolves symlinks when checking if two inputs are the same!
    inputs: nonEmptyArrayUniqueBy(
      (inputPath) => inputPath.realpath,
      flattenNonEmptyArray(
        mapNonEmptyArray(outputs, ({ outputState }) => outputState.inputs)
      )
    ),
    outputPath: { tag: "NullOutputPath" },
    env,
    getNow
  });
  for (const output of outputs) {
    const outputStatus = {
      tag: "ElmMakeTypecheckOnly",
      elmDurationMs: -1,
      walkerDurationMs: -1,
      kill
    };
    outputsWithStatus.push({ ...output, outputStatus });
    output.outputState.dirty = false;
    output.outputState.setStatus(outputStatus);
    updateStatusLine({
      logger,
      runMode,
      outputPath: output.outputPath,
      outputState: output.outputState,
      index: output.index,
      total
    });
  }
  const [elmMakeResult, allRelatedElmFilePathsResults] = await Promise.all([
    promise.then((result) => {
      const durationMs = getNow().getTime() - startTimestamp;
      for (const output of outputsWithStatus) {
        output.outputStatus.elmDurationMs = durationMs;
      }
      return result;
    }),
    Promise.resolve().then(
      () => outputsWithStatus.map(
        (output) => {
          const thisStartTimestamp = getNow().getTime();
          const allRelatedElmFilePathsResult = getAllRelatedElmFilePaths(
            elmJsonPath,
            output.outputState.inputs
          );
          output.outputStatus.walkerDurationMs = getNow().getTime() - thisStartTimestamp;
          return {
            ...output,
            allRelatedElmFilePathsResult
          };
        }
      )
    )
  ]);
  for (const {
    index,
    outputPath,
    outputState,
    allRelatedElmFilePathsResult
  } of allRelatedElmFilePathsResults) {
    if (outputState.dirty || elmMakeResult.tag === "Killed") {
      outputState.setStatus({ tag: "Interrupted" });
      updateStatusLine({
        logger,
        runMode,
        outputPath,
        outputState,
        index,
        total
      });
      continue;
    }
    outputState.allRelatedElmFilePaths = allRelatedElmFilePathsWithFallback(
      allRelatedElmFilePathsResult,
      outputState
    );
    const combinedResult = combineResults(
      onlyElmMakeErrorsRelatedToOutput(outputState, elmMakeResult),
      allRelatedElmFilePathsResult
    );
    const proxyFileResult = needsToWriteProxyFile(
      outputPath.theOutputPath,
      Buffer.from(
        versionedIdentifier(
          outputPath.targetName,
          webSocketPort,
          webSocketToken
        )
      )
    );
    switch (proxyFileResult.tag) {
      case "Needed":
        try {
          fs5.mkdirSync(absoluteDirname(outputPath.theOutputPath), {
            recursive: true
          });
          fs5.writeFileSync(
            outputPath.theOutputPath,
            proxyFile(
              outputPath,
              getNow().getTime(),
              outputState.browserUiPosition,
              webSocketPort,
              webSocketToken,
              logger.config.debug
            )
          );
          outputState.setStatus({ tag: "NotWrittenToDisk" });
        } catch (unknownError) {
          const error = toError(unknownError);
          outputState.setStatus({ tag: "WriteProxyOutputError", error });
        }
        break;
      case "NotNeeded":
        outputState.setStatus({ tag: "NotWrittenToDisk" });
        break;
      case "ReadError":
        outputState.setStatus({
          tag: "NeedsToWriteProxyFileReadError",
          error: proxyFileResult.error,
          triedPath: outputPath.theOutputPath
        });
        break;
    }
    switch (combinedResult.tag) {
      case "elm make success + walker success":
        break;
      // In all of the remaining cases, `elm make` and
      // `getAllRelatedElmFilePaths` errors are more important than proxy file
      // errors.
      case "elm make success + walker failure":
        outputState.setStatus(combinedResult.walkerError);
        break;
      case "elm make failure + walker success":
        outputState.setStatus(combinedResult.elmMakeError);
        break;
      case "elm make failure + walker failure":
        outputState.setStatus(combinedResult.elmMakeError);
        break;
    }
    updateStatusLine({
      logger,
      runMode,
      outputPath,
      outputState,
      index,
      total
    });
  }
}
function onlyElmMakeErrorsRelatedToOutput(outputState, elmMakeResult) {
  if (!(elmMakeResult.tag === "ElmMakeError" && elmMakeResult.error.type === "compile-errors")) {
    return elmMakeResult;
  }
  const errors = elmMakeResult.error.errors.filter(
    (error) => outputState.allRelatedElmFilePaths.has(error.path)
  );
  return isNonEmptyArray(errors) ? {
    tag: "ElmMakeError",
    error: { type: "compile-errors", errors },
    extraError: elmMakeResult.extraError
  } : { tag: "Success" };
}
function combineResults(elmMakeResult, allRelatedElmFilePathsResult) {
  switch (elmMakeResult.tag) {
    case "Success":
      switch (allRelatedElmFilePathsResult.tag) {
        case "Success":
          return {
            tag: "elm make success + walker success",
            allRelatedElmFilePaths: allRelatedElmFilePathsResult.allRelatedElmFilePaths
          };
        default:
          return {
            tag: "elm make success + walker failure",
            walkerError: allRelatedElmFilePathsResult
          };
      }
    default:
      switch (allRelatedElmFilePathsResult.tag) {
        case "Success":
          return {
            tag: "elm make failure + walker success",
            elmMakeError: elmMakeResult,
            allRelatedElmFilePaths: allRelatedElmFilePathsResult.allRelatedElmFilePaths
          };
        default:
          return {
            tag: "elm make failure + walker failure",
            elmMakeError: elmMakeResult,
            walkerError: allRelatedElmFilePathsResult
          };
      }
  }
}
function printSpaceForOutputs(logger, runMode, outputActions) {
  if (!logger.config.isTTY) {
    return;
  }
  if (isNonEmptyArray(outputActions.outputsWithoutAction)) {
    for (let index = 0; index < outputActions.total; index++) {
      const output = outputActions.outputsWithoutAction.find(
        (output2) => output2.index === index
      );
      if (output === void 0) {
        writeNewLines(logger, 1);
      } else {
        logger.write(
          statusLine(
            logger.config,
            runMode,
            output.outputPath,
            output.outputState
          )
        );
      }
    }
  } else {
    writeNewLines(logger, outputActions.total);
  }
}
function writeNewLines(logger, count) {
  if (count > 0) {
    logger.write("\n".repeat(count - 1));
  }
}
function updateStatusLine({
  logger,
  runMode,
  outputPath,
  outputState,
  index,
  total
}) {
  logger.moveCursor(0, -total + index);
  logger.clearLine(0);
  logger.write(statusLine(logger.config, runMode, outputPath, outputState));
  logger.moveCursor(0, total - index - 1);
}
var EMOJI = {
  QueuedForElmMake: {
    emoji: "\u26AA\uFE0F",
    description: "queued for elm make"
  },
  QueuedForPostprocess: {
    emoji: "\u{1F7E2}",
    description: "elm make done \u2013 queued for postprocess"
  },
  Busy: {
    emoji: "\u23F3",
    description: "elm make or postprocess"
  },
  Error: {
    emoji: "\u{1F6A8}",
    description: "error"
  },
  Skipped: {
    emoji: "\u26D4\uFE0F",
    description: "skipped"
  },
  Success: {
    emoji: "\u2705",
    description: "success"
  },
  Information: {
    emoji: "\u2139\uFE0F",
    description: "info"
  },
  Stats: {
    emoji: "\u{1F4CA}",
    description: "stats"
  }
};
function emojiWidthFix({
  emoji,
  column,
  isTTY
}) {
  return `${emoji}${isTTY ? cursorHorizontalAbsolute(column) : ""}`;
}
function targetNameEmojiTweak(loggerConfig, targetName) {
  const match = STARTS_WITH_EMOJI_REGEX.exec(targetName);
  if (match === null) {
    return { targetName, delta: 0 };
  }
  const content = match[0];
  if (!loggerConfig.fancy) {
    return {
      targetName: markAsTargetName(targetName.slice(content.length)),
      delta: 0
    };
  }
  const start = emojiWidthFix({
    emoji: content.trim(),
    column: 6,
    // 2 chars of status emoji, 2 chars of this emoji and 2 spaces.
    isTTY: loggerConfig.isTTY
  });
  return {
    targetName: markAsTargetName(
      `${start} ${targetName.slice(content.length)}`
    ),
    // `start.length` is pretty big: Emojis can take many characters, and the
    // escape code to move the cursor takes some as well. In reality, it takes
    // just 2 characters of screen width (2 chars of emoji).
    delta: -start.length + 2
  };
}
function printStatusLinesForElmJsonsErrors(logger, project) {
  for (const { outputPath } of project.elmJsonsErrors) {
    const { targetName, delta } = targetNameEmojiTweak(
      logger.config,
      outputPath.targetName
    );
    logger.write(
      printStatusLine({
        maxWidth: logger.config.columns - delta,
        fancy: logger.config.fancy,
        isTTY: logger.config.isTTY,
        emojiName: "Error",
        string: logger.config.fancy ? targetName : `${targetName}: error`
      })
    );
  }
}
function printErrors(logger, errors) {
  const errorStrings = Array.from(
    new Set(
      errors.map(
        (template2) => toTerminalString(
          template2,
          logger.config.columns,
          logger.config.noColor
        )
      )
    )
  );
  logger.write("");
  logger.write(errorStrings.join("\n\n"));
  logger.write("");
  printNumErrors(logger, errorStrings.length);
}
function printNumErrors(logger, numErrors) {
  logger.write(
    printStatusLine({
      maxWidth: logger.config.columns,
      fancy: logger.config.fancy,
      isTTY: logger.config.isTTY,
      emojiName: "Error",
      string: `${bold(numErrors.toString())} error${numErrors === 1 ? "" : "s"} found`
    })
  );
}
function statusLine(loggerConfig, runMode, outputPath, outputState) {
  const { status } = outputState;
  const { targetName, delta } = targetNameEmojiTweak(
    loggerConfig,
    outputPath.targetName
  );
  const helper = (emojiName, string9) => printStatusLine({
    maxWidth: loggerConfig.columns - delta,
    fancy: loggerConfig.fancy,
    isTTY: loggerConfig.isTTY,
    emojiName,
    string: string9
  });
  const withExtraDetailsAtEnd = (extra, emojiName, start) => {
    const strings = extra.flatMap((item) => item ?? []);
    if (!isNonEmptyArray(strings)) {
      return helper(emojiName, start);
    }
    const startLength = (loggerConfig.fancy ? start.length + 3 : start.length) + delta;
    const end = strings.join("   ");
    const max = Math.min(loggerConfig.columns, 100);
    const padding = loggerConfig.isTTY ? Math.max(3, max - end.length - startLength) : 3;
    return helper(
      emojiName,
      `${start}\0${" ".repeat(padding - 1)}${end}`
    ).replace(/\0(.*)$/, dim(" $1"));
  };
  switch (status.tag) {
    case "NotWrittenToDisk": {
      return withExtraDetailsAtEnd(
        [maybePrintDurations(loggerConfig, outputState.flushDurations())],
        "Success",
        loggerConfig.fancy ? targetName : `${targetName}: success`
      );
    }
    case "Success": {
      return withExtraDetailsAtEnd(
        [
          maybePrintFileSize({
            runMode,
            compilationMode: outputState.compilationMode,
            elmFileSize: status.elmFileSize,
            postprocessFileSize: status.postprocessFileSize,
            fancy: loggerConfig.fancy
          }),
          maybePrintDurations(loggerConfig, outputState.flushDurations())
        ],
        "Success",
        loggerConfig.fancy ? targetName : `${targetName}: success`
      );
    }
    case "ElmMake": {
      const arg = compilationModeToArg(status.compilationMode);
      const flags = arg === void 0 ? "" : ` ${arg}`;
      return helper("Busy", `${targetName}: elm make${flags}`);
    }
    case "ElmMakeTypecheckOnly":
      return helper("Busy", `${targetName}: elm make (typecheck only)`);
    case "Postprocess":
      return helper("Busy", `${targetName}: postprocess`);
    case "Interrupted":
      return helper("Busy", `${targetName}: interrupted`);
    case "QueuedForElmMake":
      return helper("QueuedForElmMake", `${targetName}: queued`);
    case "QueuedForPostprocess":
      return helper("QueuedForPostprocess", `${targetName}: elm make done`);
    /* v8 ignore next */
    case "ElmNotFoundError":
    case "CommandNotFoundError":
    case "OtherSpawnError":
    case "UnexpectedElmMakeOutput":
    case "PostprocessStdinWriteError":
    case "PostprocessNonZeroExit":
    case "ElmWatchNodeMissingScript":
    case "ElmWatchNodeImportError":
    case "ElmWatchNodeDefaultExportNotFunction":
    case "ElmWatchNodeRunError":
    case "ElmWatchNodeBadReturnValue":
    case "ElmMakeCrashError":
    case "ElmMakeJsonParseError":
    case "ElmMakeError":
    case "ElmJsonReadError":
    case "ElmJsonDecodeError":
    case "ImportWalkerFileSystemError":
    case "NeedsToWriteProxyFileReadError":
    case "ReadOutputError":
    case "WriteOutputError":
    case "WriteProxyOutputError":
      return helper(
        "Error",
        loggerConfig.fancy ? targetName : `${targetName}: error`
      );
  }
}
function printStatusLine({
  maxWidth,
  fancy,
  isTTY,
  emojiName,
  string: string9
}) {
  const emojiString = emojiWidthFix({
    emoji: EMOJI[emojiName].emoji,
    column: 3,
    isTTY
  });
  const stringWithEmoji = fancy ? `${emojiString} ${string9}` : string9;
  if (!isTTY) {
    return stringWithEmoji;
  }
  const length = fancy ? string9.length + 3 : string9.length;
  return length <= maxWidth ? stringWithEmoji : fancy ? (
    // Again, account for the emoji.
    `${emojiString} ${string9.slice(0, maxWidth - 4)}\u2026`
  ) : `${string9.slice(0, maxWidth - 3)}...`;
}
function maybePrintFileSize({
  runMode,
  compilationMode,
  elmFileSize,
  postprocessFileSize,
  fancy
}) {
  switch (runMode) {
    case "make":
      switch (compilationMode) {
        case "debug":
        case "standard":
          return void 0;
        case "optimize":
          return postprocessFileSize === elmFileSize ? printFileSize(elmFileSize) : `${printFileSize(elmFileSize)} ${fancy ? "\u2192" : "->"} ${printFileSize(postprocessFileSize)} (${(postprocessFileSize / elmFileSize * 100).toFixed(1)} %)`;
      }
    case "hot":
      return void 0;
  }
}
function maybePrintDurations(loggerConfig, durations) {
  if (!isNonEmptyArray(durations)) {
    return void 0;
  }
  const newDurations = durations.some(
    (duration) => duration.tag === "QueuedForElmMake"
  ) ? durations : [{ tag: "QueuedForElmMake", durationMs: 0 }, ...durations];
  return mapNonEmptyArray(
    newDurations,
    (duration) => printDuration(
      /* v8 ignore next */
      loggerConfig.mockedTimings ? mockDuration(duration) : duration,
      loggerConfig.fancy
    )
  ).join(" | ");
}
function printDuration(duration, fancy) {
  switch (duration.tag) {
    case "QueuedForElmMake":
      return `${printDurationMs(duration.durationMs)} Q`;
    case "ElmMake":
    case "ElmMakeTypecheckOnly":
      return `${printDurationMs(duration.elmDurationMs)} ${duration.tag === "ElmMake" ? "E" : "T"}${duration.walkerDurationMs === -1 ? "" : ` ${fancy ? "\xA6" : "/"} ${printDurationMs(
        duration.walkerDurationMs
      )} W`}`;
    case "Inject":
      return `${printDurationMs(duration.durationMs)} I`;
    case "QueuedForPostprocess":
      return `${printDurationMs(duration.durationMs)} R`;
    case "Postprocess":
      return `${printDurationMs(duration.durationMs)} P`;
  }
}
function mockDuration(duration) {
  switch (duration.tag) {
    case "QueuedForElmMake":
      return {
        tag: "QueuedForElmMake",
        durationMs: 1
      };
    case "ElmMake":
      return {
        tag: "ElmMake",
        elmDurationMs: 1234,
        walkerDurationMs: duration.walkerDurationMs === -1 ? -1 : 55
      };
    case "ElmMakeTypecheckOnly":
      return {
        tag: "ElmMakeTypecheckOnly",
        elmDurationMs: 765,
        walkerDurationMs: 50
      };
    case "Inject":
      return {
        tag: "Inject",
        durationMs: 9
      };
    case "QueuedForPostprocess":
      return {
        tag: "QueuedForPostprocess",
        durationMs: 0
      };
    case "Postprocess":
      return {
        tag: "Postprocess",
        durationMs: 31234
      };
  }
}
function extractErrors(project) {
  return [
    ...project.elmJsonsErrors.map(renderElmJsonError),
    ...Array.from(project.elmJsons).flatMap(
      ([elmJsonPath, outputs]) => Array.from(outputs).flatMap(
        ([outputPath, { status }]) => renderOutputErrors(
          project.elmWatchJsonPath,
          elmJsonPath,
          outputPath,
          status,
          true
        )
      )
    )
  ];
}
function renderElmJsonError({
  outputPath,
  error
}) {
  switch (error.tag) {
    case "ElmJsonNotFound":
      return elmJsonNotFound(
        outputPath,
        error.elmJsonNotFound,
        error.foundElmJsonPaths
      );
    case "NonUniqueElmJsonPaths":
      return nonUniqueElmJsonPaths(
        outputPath,
        error.nonUniqueElmJsonPaths
      );
    case "InputsNotFound":
      return inputsNotFound(outputPath, error.inputsNotFound);
    case "InputsFailedToResolve":
      return inputsFailedToResolve(
        outputPath,
        error.inputsFailedToResolve
      );
    case "DuplicateInputs":
      return duplicateInputs(outputPath, error.duplicates);
  }
}
function renderOutputErrors(elmWatchJsonPath, elmJsonPath, outputPath, status, includeStuckInProgressState = false) {
  switch (status.tag) {
    case "NotWrittenToDisk":
      return [];
    /* v8 ignore start */
    case "ElmMake":
    case "ElmMakeTypecheckOnly":
    case "Postprocess":
    case "Interrupted":
    case "QueuedForElmMake":
      return includeStuckInProgressState ? [stuckInProgressState(outputPath, status.tag)] : [];
    /* v8 ignore stop */
    // If there are `elm make` errors we skip postprocessing (fail fast).
    case "QueuedForPostprocess":
      return [];
    case "Success":
      return [];
    /* v8 ignore start */
    case "ElmNotFoundError":
      return [elmNotFoundError(outputPath, status.command)];
    /* v8 ignore stop */
    case "CommandNotFoundError":
      return [commandNotFoundError(outputPath, status.command)];
    /* v8 ignore start */
    case "OtherSpawnError":
      return [otherSpawnError(outputPath, status.error, status.command)];
    /* v8 ignore stop */
    case "UnexpectedElmMakeOutput":
      return [
        unexpectedElmMakeOutput(
          outputPath,
          status.exitReason,
          status.stdout,
          status.stderr,
          status.command
        )
      ];
    // This is covered on macOS and Windows, but not Linux.
    /* v8 ignore start */
    case "PostprocessStdinWriteError":
      return [
        postprocessStdinWriteError(
          outputPath,
          status.error,
          status.command
        )
      ];
    /* v8 ignore stop */
    case "PostprocessNonZeroExit":
      return [
        postprocessNonZeroExit(
          outputPath,
          status.exitReason,
          status.stdout,
          status.stderr,
          status.command
        )
      ];
    case "ElmWatchNodeMissingScript":
      return [elmWatchNodeMissingScript(elmWatchJsonPath)];
    case "ElmWatchNodeImportError":
      return [
        elmWatchNodeImportError(
          status.scriptPath,
          status.error,
          status.stdout,
          status.stderr
        )
      ];
    case "ElmWatchNodeDefaultExportNotFunction":
      return [
        elmWatchNodeDefaultExportNotFunction(
          status.scriptPath,
          status.imported,
          status.typeofDefault,
          status.stdout,
          status.stderr
        )
      ];
    case "ElmWatchNodeRunError":
      return [
        elmWatchNodeRunError(
          status.scriptPath,
          status.args,
          status.error,
          status.stdout,
          status.stderr
        )
      ];
    case "ElmWatchNodeBadReturnValue":
      return [
        elmWatchNodeBadReturnValue(
          status.scriptPath,
          status.args,
          status.returnValue,
          status.stdout,
          status.stderr
        )
      ];
    case "ElmMakeCrashError":
      return [
        elmMakeCrashError(
          outputPath,
          status.beforeError,
          status.error,
          status.command
        )
      ];
    case "ElmMakeJsonParseError":
      return [
        elmMakeJsonParseError(
          outputPath,
          status.error,
          status.errorFilePath,
          status.command
        )
      ];
    case "ElmMakeError":
      switch (status.error.type) {
        case "error":
          return [
            elmMakeGeneralError(
              outputPath,
              elmJsonPath,
              status.error,
              status.extraError
            )
          ];
        case "compile-errors":
          return status.error.errors.flatMap(
            (error) => error.problems.map(
              (problem) => elmMakeProblem(error.path, problem, status.extraError)
            )
          );
      }
    case "ElmJsonReadError":
      return [readElmJson(status.elmJsonPath, status.error)];
    case "ElmJsonDecodeError":
      return [decodeElmJson(status.elmJsonPath, status.error)];
    case "ImportWalkerFileSystemError":
      return [importWalkerFileSystemError(outputPath, status.error)];
    case "NeedsToWriteProxyFileReadError":
      return [
        needsToWriteProxyFileReadError(
          outputPath,
          status.error,
          status.triedPath
        )
      ];
    case "ReadOutputError":
      return [
        readOutputError(outputPath, status.error, status.triedPath)
      ];
    case "WriteOutputError":
      return [
        writeOutputError(
          outputPath,
          status.error,
          status.reasonForWriting
        )
      ];
    case "WriteProxyOutputError":
      return [writeProxyOutputError(outputPath, status.error)];
  }
}
function getAllRelatedElmFilePaths(elmJsonPath, inputs) {
  const result = readSourceDirectories(elmJsonPath);
  switch (result.tag) {
    case "Parsed":
      return walkImports(
        result.sourceDirectories,
        mapNonEmptyArray(inputs, (input) => input.realpath)
      );
    default:
      return result;
  }
}
function allRelatedElmFilePathsWithFallback(walkerResult, outputState) {
  switch (walkerResult.tag) {
    case "Success":
      return walkerResult.allRelatedElmFilePaths;
    case "ImportWalkerFileSystemError":
      return walkerResult.relatedElmFilePathsUntilError;
    case "ElmJsonReadError":
    case "ElmJsonDecodeError":
      return new Set(
        mapNonEmptyArray(outputState.inputs, (inputPath) => inputPath.realpath)
      );
  }
}
function ensureAllRelatedElmFilePaths(elmJsonPath, outputState) {
  if (outputState.allRelatedElmFilePaths.size === 0) {
    const result = getAllRelatedElmFilePaths(elmJsonPath, outputState.inputs);
    outputState.allRelatedElmFilePaths = allRelatedElmFilePathsWithFallback(
      result,
      outputState
    );
  }
}

// src/Help.ts
var elmWatchJson2 = bold("elm-watch.json");
function render(loggerConfig) {
  const symbolLegend = loggerConfig.fancy ? `
${bold("Symbol legend:")}

${Object.values(EMOJI).map(({ emoji, description }) => {
    const indent = "    ";
    return `${indent}${emojiWidthFix({
      emoji,
      column: indent.length + 3,
      isTTY: loggerConfig.isTTY
    })} ${description}`;
  }).join("\n")}
` : "";
  return `
${bold("elm-watch init")}
    Create a minimal ${elmWatchJson2} in the current directory.

${bold("elm-watch make [--debug|--optimize] [target names...]")}
    Compile Elm code into JS. Similar to ${bold("elm make")}.

${bold("elm-watch hot [target names...]")}
    Recompile whenever your Elm files change,
    and reload the compiled JS in the browser.
    You can switch to ${bold("--debug")} and ${bold("--optimize")}
    mode in the browser.

By default all targets in the closest ${elmWatchJson2} are built.
Pass ${bold("target names")} to only build some. Names are matched by substring!

${dim("---")}
${symbolLegend}
${bold("Durations legend:")}

    ${bold("Q")} queued for elm make
    ${bold("E")} elm make
    ${bold("T")} elm make (typecheck only)
    ${bold("W")} find all related Elm file paths
    ${bold("I")} inject hot reloading code
    ${bold("R")} queued for postprocess
    ${bold("P")} postprocess
    ${bold(loggerConfig.fancy ? "\xA6" : "/")} next is run in parallel

${dim("---")}

${bold("Environment variables:")}
    ${bold(NO_COLOR)}
        Disable colored output

    ${bold(ELM_WATCH_OPEN_EDITOR)}
        Open your editor when clicking error locations in the browser
        https://lydell.github.io/elm-watch/browser-ui/#clickable-error-locations

    ${bold(ELM_WATCH_EXIT_ON_STDIN_END)}
        Exit elm-watch when stdin ends

${bold("Documentation:")}
    https://lydell.github.io/elm-watch/

${bold("Version:")}
    1.2.2
`.trim();
}

// src/Init.ts
var fs6 = require("fs");
var elmWatchJson3 = bold("elm-watch.json");
function init(cwd, logger, args) {
  if (isNonEmptyArray(args)) {
    logger.writeToStderrMakesALotOfSenseHere(
      `${bold("elm-watch init")} takes no arguments.`
    );
    return 1;
  }
  const elmWatchJsonPath = markAsElmWatchJsonPath(
    absolutePathFromString(cwd, "elm-watch.json")
  );
  if (fs6.existsSync(elmWatchJsonPath)) {
    logger.writeToStderrMakesALotOfSenseHere(
      `${elmWatchJson3} already exists in the current directory!`
    );
    return 1;
  }
  const example2 = example(cwd, elmWatchJsonPath, {
    elmFiles: [],
    output: void 0
  });
  try {
    fs6.writeFileSync(elmWatchJsonPath, example2);
  } catch (unknownError) {
    const error = toError(unknownError);
    logger.writeToStderrMakesALotOfSenseHere(
      `Failed to write ${elmWatchJson3}:

${error.message}`
    );
    return 1;
  }
  logger.write(
    `
Created a minimal ${elmWatchJson3} in the current directory to get you started.
Go check it out!

Documentation: https://lydell.github.io/elm-watch/elm-watch.json/
  `.trim()
  );
  return 0;
}

// src/Run.ts
var crypto3 = require("crypto");

// src/CliArgs.ts
function parseArgs(runMode, args) {
  let debug = false;
  let optimize = false;
  const unknownFlags2 = [];
  const targetsSubstrings = [];
  for (const arg of args) {
    switch (arg) {
      case "--debug":
        debug = true;
        break;
      case "--optimize":
        optimize = true;
        break;
      default:
        if (arg.startsWith("-")) {
          unknownFlags2.push(arg);
        } else {
          targetsSubstrings.push(arg);
        }
    }
  }
  switch (runMode) {
    case "hot":
      if (debug || optimize) {
        return { tag: "DebugOptimizeForHot" };
      }
      break;
    case "make":
      if (debug && optimize) {
        return { tag: "DebugOptimizeClash" };
      }
      break;
  }
  if (isNonEmptyArray(unknownFlags2)) {
    return {
      tag: "UnknownFlags",
      unknownFlags: unknownFlags2
    };
  }
  return {
    tag: "Success",
    compilationMode: debug ? "debug" : optimize ? "optimize" : "standard",
    targetsSubstrings
  };
}

// src/ElmWatchStuffJson.ts
var Codec14 = require("tiny-decoders");
var Target2 = Codec14.fields({
  compilationMode: Codec14.field(CompilationMode, { optional: true }),
  browserUiPosition: Codec14.field(BrowserUiPosition, { optional: true }),
  openErrorOverlay: Codec14.field(Codec14.boolean, { optional: true })
});
var ElmWatchStuffJson = Codec14.fields({
  port: Port,
  webSocketToken: Codec14.field(WebSocketToken, { optional: true }),
  targets: Codec14.record(Target2)
});
function readAndParse(elmWatchStuffJsonPath) {
  const parsed = readJsonFile(elmWatchStuffJsonPath, ElmWatchStuffJson);
  switch (parsed.tag) {
    case "DecoderError":
      return {
        tag: "ElmWatchStuffJsonDecodeError",
        error: parsed.error
      };
    case "ReadError":
      return parsed.error.code === "ENOENT" ? {
        tag: "NoElmWatchStuffJson",
        elmWatchStuffJsonPath
      } : {
        tag: "ElmWatchStuffJsonReadError",
        errors: parsed.error
      };
    case "Valid":
      return {
        tag: "Parsed",
        elmWatchStuffJsonPath,
        elmWatchStuffJson: parsed.value
      };
  }
}

// src/Hot.ts
var childProcess2 = require("child_process");
var chokidar = require("chokidar");
var crypto2 = require("crypto");
var fs7 = require("fs");
var path8 = require("path");
var Codec16 = require("tiny-decoders");
var import_url = require("url");

// client/WebSocketMessages.ts
var Codec15 = require("tiny-decoders");
var nonNegativeIntCodec = Codec15.flatMap(Codec15.number, {
  decoder: (value) => Number.isInteger(value) && value >= 0 ? { tag: "Valid", value } : {
    tag: "DecoderError",
    error: {
      tag: "custom",
      path: [],
      message: "Expected a non-negative integer",
      got: value
    }
  },
  encoder: (value) => value
});
var OpenEditorError = Codec15.taggedUnion("tag", [
  {
    tag: Codec15.tag("EnvNotSet")
  },
  {
    tag: Codec15.tag("InvalidFilePath"),
    message: Codec15.string
  },
  {
    tag: Codec15.tag("CommandFailed"),
    message: Codec15.string
  }
]);
var ErrorLocation = Codec15.taggedUnion("tag", [
  {
    tag: Codec15.tag("FileOnly"),
    file: AbsolutePath
  },
  {
    tag: Codec15.tag("FileWithLineAndColumn"),
    file: AbsolutePath,
    line: Codec15.number,
    column: Codec15.number
  },
  {
    tag: Codec15.tag("Target"),
    targetName: Codec15.string
  }
]);
var CompileError2 = Codec15.fields({
  title: Codec15.string,
  location: Codec15.field(ErrorLocation, { optional: true }),
  htmlContent: Codec15.string
});
var StatusChange = Codec15.taggedUnion("tag", [
  {
    tag: Codec15.tag("AlreadyUpToDate"),
    compilationMode: CompilationMode,
    browserUiPosition: BrowserUiPosition
  },
  {
    tag: Codec15.tag("Busy"),
    compilationMode: CompilationMode,
    browserUiPosition: BrowserUiPosition
  },
  {
    tag: Codec15.tag("CompileError"),
    compilationMode: CompilationMode,
    browserUiPosition: BrowserUiPosition,
    openErrorOverlay: Codec15.boolean,
    errors: Codec15.array(CompileError2),
    foregroundColor: Codec15.string,
    backgroundColor: Codec15.string
  },
  {
    tag: Codec15.tag("ElmJsonError"),
    error: Codec15.string
  },
  {
    tag: Codec15.tag("ClientError"),
    message: Codec15.string
  }
]);
var SuccessfullyCompiledFields = {
  code: Codec15.string,
  elmCompiledTimestamp: Codec15.number,
  compilationMode: CompilationMode,
  browserUiPosition: BrowserUiPosition
};
var SuccessfullyCompiled = Codec15.taggedUnion("tag", [
  {
    tag: Codec15.tag("SuccessfullyCompiled"),
    ...SuccessfullyCompiledFields
  }
]);
var WebSocketToClientMessage = Codec15.taggedUnion("tag", [
  {
    tag: Codec15.tag("FocusedTabAcknowledged")
  },
  {
    tag: Codec15.tag("OpenEditorFailed"),
    error: OpenEditorError
  },
  {
    tag: Codec15.tag("StatusChanged"),
    status: StatusChange
  },
  {
    tag: Codec15.tag("SuccessfullyCompiled"),
    ...SuccessfullyCompiledFields
  },
  {
    tag: Codec15.tag("SuccessfullyCompiledButRecordFieldsChanged")
  }
]);
var WebSocketToServerMessage = Codec15.taggedUnion("tag", [
  {
    tag: Codec15.tag("ChangedCompilationMode"),
    compilationMode: CompilationMode
  },
  {
    tag: Codec15.tag("ChangedBrowserUiPosition"),
    browserUiPosition: BrowserUiPosition
  },
  {
    tag: Codec15.tag("ChangedOpenErrorOverlay"),
    openErrorOverlay: Codec15.boolean
  },
  {
    tag: Codec15.tag("FocusedTab")
  },
  {
    tag: Codec15.tag("PressedOpenEditor"),
    file: AbsolutePath,
    // Disallow negative numbers since they might be parsed as command line flags
    // in the user’s command, potentially causing something unwanted.
    line: nonNegativeIntCodec,
    column: nonNegativeIntCodec
  }
]);
function encodeWebSocketToClientMessage(message) {
  switch (message.tag) {
    // Optimization: Avoid encoding megabytes of JS code as a JSON string.
    // With a large Elm app, `JSON.stringify` + `JSON.parse` can time ~40 ms.
    case "SuccessfullyCompiled": {
      const shortMessage = { ...message, code: "" };
      return `//${Codec15.JSON.stringify(SuccessfullyCompiled, shortMessage)}
${message.code}`;
    }
    default:
      return Codec15.JSON.stringify(WebSocketToClientMessage, message);
  }
}

// src/Project.ts
var os3 = require("os");
var path7 = require("path");
var OutputState = class {
  constructor(inputs, compilationMode, browserUiPosition, openErrorOverlay, getNow) {
    this.getNow = getNow;
    // This one has a method for mutating, for measuring how long time is spent in
    // different statuses.
    this._status = { tag: "NotWrittenToDisk" };
    this._durations = [];
    this._lastStartTimestamp = 0;
    this.openErrorOverlay = false;
    this.allRelatedElmFilePaths = /* @__PURE__ */ new Set();
    // We only calculate `recordFields` in optimize mode. Having `| undefined`
    // makes that more clear.
    this.recordFields = void 0;
    this.dirty = true;
    this.inputs = inputs;
    this.compilationMode = compilationMode;
    this.browserUiPosition = browserUiPosition;
    this.openErrorOverlay = openErrorOverlay;
  }
  flushDurations() {
    const durations = this._durations.slice();
    this._durations.length = 0;
    return durations;
  }
  get status() {
    return this._status;
  }
  setStatus(status) {
    const lastStartTimestamp = this._lastStartTimestamp;
    this._lastStartTimestamp = this.getNow().getTime();
    switch (this._status.tag) {
      case "ElmMake":
        this._durations.push({
          tag: "ElmMake",
          elmDurationMs: this._status.elmDurationMs,
          walkerDurationMs: this._status.walkerDurationMs
        });
        if (this._status.injectDurationMs !== -1) {
          this._durations.push({
            tag: "Inject",
            durationMs: this._status.injectDurationMs
          });
        }
        break;
      case "ElmMakeTypecheckOnly":
        this._durations.push({
          tag: "ElmMakeTypecheckOnly",
          elmDurationMs: this._status.elmDurationMs,
          walkerDurationMs: this._status.walkerDurationMs
        });
        break;
      case "Postprocess":
      case "QueuedForElmMake":
      case "QueuedForPostprocess":
        this._durations.push({
          tag: this._status.tag,
          durationMs: this._lastStartTimestamp - lastStartTimestamp
        });
        break;
      default:
        this._durations.length = 0;
    }
    this._status = status;
  }
};
function initProject({
  env,
  getNow,
  compilationMode,
  elmWatchJsonPath,
  config,
  enabledTargetsSubstrings,
  elmWatchStuffDir,
  elmWatchStuffJsonPath,
  elmWatchStuffJson: elmWatchStuffJson2
}) {
  const disabledOutputs = [];
  const elmJsonsErrors = [];
  const elmJsons = /* @__PURE__ */ new Map();
  const potentialOutputDuplicates = /* @__PURE__ */ new Map();
  for (const [index, [targetName, target]] of Object.entries(
    config.targets
  ).entries()) {
    const outputPath = {
      tag: "OutputPath",
      theOutputPath: absolutePathFromString(
        absoluteDirname(elmWatchJsonPath),
        target.output
      ),
      temporaryOutputPath: absolutePathFromString(
        elmWatchStuffDir,
        `${index}.js`
      ),
      originalString: target.output,
      targetName: markAsTargetName(targetName)
    };
    const previousOutput = potentialOutputDuplicates.get(
      outputPath.theOutputPath
    );
    if (previousOutput === void 0) {
      potentialOutputDuplicates.set(outputPath.theOutputPath, [
        outputPath.originalString
      ]);
    } else {
      previousOutput.push(outputPath.originalString);
    }
    if (enabledTargetsSubstrings.some(
      (substring) => targetName.includes(substring)
    )) {
      const resolveElmJsonResult = resolveElmJson(
        elmWatchJsonPath,
        target.inputs
      );
      const persisted = elmWatchStuffJson2?.targets[targetName];
      const {
        compilationMode: thisCompilationMode = compilationMode,
        browserUiPosition = "BottomLeft",
        openErrorOverlay = false
      } = persisted ?? {};
      switch (resolveElmJsonResult.tag) {
        case "Success": {
          const previous = elmJsons.get(resolveElmJsonResult.elmJsonPath) ?? [];
          previous.push([
            outputPath,
            new OutputState(
              resolveElmJsonResult.inputs,
              thisCompilationMode,
              browserUiPosition,
              openErrorOverlay,
              getNow
            )
          ]);
          elmJsons.set(resolveElmJsonResult.elmJsonPath, previous);
          break;
        }
        default:
          elmJsonsErrors.push({
            outputPath,
            compilationMode: thisCompilationMode,
            browserUiPosition,
            openErrorOverlay,
            error: resolveElmJsonResult
          });
          break;
      }
    } else {
      disabledOutputs.push(outputPath);
    }
  }
  const duplicateOutputs2 = Array.from(potentialOutputDuplicates).filter(([, outputPaths]) => outputPaths.length >= 2).map(([absolutePath, originalOutputPathStrings]) => ({
    originalOutputPathStrings,
    absolutePath
  }));
  if (isNonEmptyArray(duplicateOutputs2)) {
    return {
      tag: "DuplicateOutputs",
      duplicates: duplicateOutputs2
    };
  }
  const watchRoots = getWatchRoots(
    elmWatchJsonPath,
    Array.from(elmJsons.keys())
  );
  const maxParallel = silentlyReadIntEnvValue(
    env[__ELM_WATCH_MAX_PARALLEL],
    os3.cpus().length
  );
  const postprocess = config.postprocess === void 0 ? { tag: "NoPostprocess" } : { tag: "Postprocess", postprocessArray: config.postprocess };
  return {
    tag: "Project",
    project: {
      watchRoots,
      elmWatchJsonPath,
      elmWatchStuffJsonPath,
      disabledOutputs,
      elmJsonsErrors,
      elmJsons,
      maxParallel,
      postprocess
    }
  };
}
function getWatchRoots(elmWatchJsonPath, elmJsons) {
  return new Set(
    filterSubDirs(path7.sep, [
      absoluteDirname(elmWatchJsonPath),
      ...elmJsons.flatMap((elmJsonPath) => {
        const result = readSourceDirectories(elmJsonPath);
        switch (result.tag) {
          case "Parsed":
            return [absoluteDirname(elmJsonPath), ...result.sourceDirectories];
          case "ElmJsonReadError":
          case "ElmJsonDecodeError":
            return [absoluteDirname(elmJsonPath)];
        }
      })
    ])
  );
}
function filterSubDirs(pathSep, paths) {
  return paths.filter(
    (root, index) => paths.every(
      (root2, index2) => (
        // Don’t compare to self.
        index === index2 || // If any other root contains this one, discard this one.
        !root.startsWith(root2.endsWith(pathSep) ? root2 : root2 + pathSep)
      )
    )
  );
}
function resolveElmJson(elmWatchJsonPath, inputStrings) {
  const inputs = [];
  const inputsNotFound2 = [];
  const inputsFailedToResolve2 = [];
  const resolved = /* @__PURE__ */ new Map();
  for (const inputString of inputStrings) {
    const uncheckedInputPath = {
      tag: "UncheckedInputPath",
      theUncheckedInputPath: absolutePathFromString(
        absoluteDirname(elmWatchJsonPath),
        inputString
      ),
      originalString: inputString
    };
    let realpath;
    try {
      realpath = absoluteRealpath(uncheckedInputPath.theUncheckedInputPath);
    } catch (unknownError) {
      const error = toError(unknownError);
      if (error.code === "ENOENT" || error.code === "ENOTDIR") {
        inputsNotFound2.push(uncheckedInputPath);
      } else {
        inputsFailedToResolve2.push({ inputPath: uncheckedInputPath, error });
      }
      continue;
    }
    const inputPath = {
      tag: "InputPath",
      theInputPath: uncheckedInputPath.theUncheckedInputPath,
      originalString: inputString,
      realpath
    };
    const previous = resolved.get(realpath);
    if (previous === void 0) {
      resolved.set(realpath, [inputPath]);
    } else {
      previous.push(inputPath);
    }
    inputs.push(inputPath);
  }
  if (isNonEmptyArray(inputsNotFound2)) {
    return {
      tag: "InputsNotFound",
      inputsNotFound: inputsNotFound2
    };
  }
  if (isNonEmptyArray(inputsFailedToResolve2)) {
    return {
      tag: "InputsFailedToResolve",
      inputsFailedToResolve: inputsFailedToResolve2
    };
  }
  const duplicateInputs2 = Array.from(resolved).filter(([, inputPaths]) => inputPaths.length >= 2).map(([resolvedPath, inputPaths]) => ({
    resolved: resolvedPath,
    inputs: inputPaths
  }));
  if (isNonEmptyArray(duplicateInputs2)) {
    return {
      tag: "DuplicateInputs",
      duplicates: duplicateInputs2
    };
  }
  const elmJsonNotFound2 = [];
  const elmJsonPaths = [];
  for (const inputPath of inputs) {
    const elmJsonPathRaw = findClosest(
      "elm.json",
      absoluteDirname(inputPath.theInputPath)
    );
    if (elmJsonPathRaw === void 0) {
      elmJsonNotFound2.push(inputPath);
    } else {
      elmJsonPaths.push({
        inputPath,
        elmJsonPath: markAsElmJsonPath(elmJsonPathRaw)
      });
    }
  }
  if (isNonEmptyArray(elmJsonNotFound2)) {
    return {
      tag: "ElmJsonNotFound",
      elmJsonNotFound: elmJsonNotFound2,
      foundElmJsonPaths: elmJsonPaths
    };
  }
  const elmJsonPathsSet = new Set(
    elmJsonPaths.map(({ elmJsonPath }) => elmJsonPath)
  );
  const uniqueElmJsonPath = getSetSingleton(elmJsonPathsSet);
  if (uniqueElmJsonPath === void 0) {
    return {
      tag: "NonUniqueElmJsonPaths",
      // At this point we know for sure that `elmJsonPaths` must be non-empty.
      nonUniqueElmJsonPaths: elmJsonPaths
    };
  }
  return {
    tag: "Success",
    elmJsonPath: uniqueElmJsonPath,
    // At this point we know for sure that `inputs` must be non-empty.
    inputs
  };
}
function getFlatOutputs(project) {
  return Array.from(project.elmJsons.entries()).flatMap(
    ([elmJsonPath, outputs]) => outputs.map(([outputPath, outputState]) => ({
      elmJsonPath,
      outputPath,
      outputState
    }))
  );
}
function projectHasFilePathThatCanBeOpenedInEditor(project, filePath) {
  return filePath === project.elmWatchJsonPath || filePath === project.elmWatchStuffJsonPath || filePath === getPostprocessElmWatchNodeScriptPath(project) || getFlatOutputs(project).some(
    ({ elmJsonPath, outputState }) => filePath === elmJsonPath || outputState.allRelatedElmFilePaths.has(filePath)
  );
}
function getPostprocessElmWatchNodeScriptPath(project) {
  switch (project.postprocess.tag) {
    case "Postprocess": {
      const [commandName, scriptPathString] = project.postprocess.postprocessArray;
      if (commandName === ELM_WATCH_NODE && scriptPathString !== void 0) {
        return absolutePathFromString(
          absoluteDirname(project.elmWatchJsonPath),
          scriptPathString
        );
      }
      return void 0;
    }
    case "NoPostprocess":
      return void 0;
  }
}
function projectToDebug(project) {
  return {
    watchRoots: Array.from(project.watchRoots),
    elmWatchJson: project.elmWatchJsonPath,
    elmWatchStuffJson: project.elmWatchStuffJsonPath,
    maxParallel: project.maxParallel,
    postprocess: project.postprocess,
    enabledTargets: Array.from(project.elmJsons.entries()).flatMap(
      ([elmJsonPath, outputs]) => outputs.map(([outputPath, outputState]) => ({
        ...outputPathToDebug(outputPath),
        compilationMode: outputState.compilationMode,
        elmJson: elmJsonPath,
        inputs: outputState.inputs.map(inputPathToDebug)
      }))
    ),
    disabledTargets: Array.from(project.disabledOutputs, outputPathToDebug),
    erroredTargets: project.elmJsonsErrors.map(
      ({ outputPath, compilationMode, error }) => ({
        error: error.tag,
        ...outputPathToDebug(outputPath),
        compilationMode
      })
    )
  };
}
function outputPathToDebug(outputPath) {
  return {
    targetName: outputPath.targetName,
    output: outputPath.theOutputPath,
    temporaryOutput: outputPath.temporaryOutputPath,
    originalString: outputPath.originalString
  };
}
function inputPathToDebug(inputPath) {
  return {
    input: inputPath.theInputPath,
    realpath: inputPath.realpath,
    originalString: inputPath.originalString
  };
}

// src/TeaProgram.ts
async function runTeaProgram(options) {
  return new Promise((resolve3, reject) => {
    const [initialModel, initialCmds] = options.init;
    let model = initialModel;
    const msgQueue = [];
    let killed = false;
    const dispatch = (dispatchedMsg) => {
      if (killed) {
        return;
      }
      const alreadyRunning = msgQueue.length > 0;
      msgQueue.push(dispatchedMsg);
      if (alreadyRunning) {
        return;
      }
      for (const msg of msgQueue) {
        const [newModel, cmds] = options.update(msg, model);
        model = newModel;
        runCmds(cmds);
      }
      msgQueue.length = 0;
    };
    const runCmds = (cmds) => {
      for (const cmd of cmds) {
        options.runCmd(
          cmd,
          mutable,
          dispatch,
          (result) => {
            cmds.length = 0;
            killed = true;
            resolve3(result);
          },
          /* v8 ignore start */
          (error) => {
            cmds.length = 0;
            killed = true;
            reject(error);
          }
          /* v8 ignore stop */
        );
        if (killed) {
          break;
        }
      }
    };
    const mutable = options.initMutable(
      dispatch,
      (result) => {
        killed = true;
        resolve3(result);
      },
      /* v8 ignore start */
      (error) => {
        killed = true;
        reject(error);
      }
      /* v8 ignore stop */
    );
    runCmds(initialCmds);
  });
}

// src/WebSocketServer.ts
var http = require("http");
var https = require("https");
var net = require("net");
var util2 = require("util");
var import_ws = require("ws");

// src/Certificate.ts
var CERTIFICATE = {
  key: `-----BEGIN PRIVATE KEY-----
MIIJQwIBADANBgkqhkiG9w0BAQEFAASCCS0wggkpAgEAAoICAQC012uZX87KEVJA
CjTlOoBX7mzfd/T9NxrBlOPhauhGrPyxZ2FmTjZSErtgS96UCUALHyaWIlfmGCtT
XcdZbLFCxNFNuK+kIpXktSO/ZLNnryUTpZFXparAUJpyfO0bjsfJr6jc21gRZFnN
C4pbB/YMDqtQr3o5AS5pqujncUOR0jBHb5EPqlAe4B8LcrB+Hza2wLwRpyGpouhK
Sg1AQDKNx8z0XwcCp1OCpgGniqwDr0QhGWZ4X+T2zivhHag2ZdbfuPYI3se9hl31
EX9X5OXNVKi+CVOu0CdsrWVMVm665A8oi/pVr+m8xZdivbEmQwNRbYLpEAc1UcE2
8yHu6PITcB9+i7bKtDMO4ULWFPO6xivXpQqXsA1og8D4yEDHrCzaD7iewPuxaAtT
bJONUMcoNobOD42K2gDs6ZYKzc2ci1GljsXfQ1iO9RSgxpmIwg7T+od5h6clZxwV
7L7YLvi06IXuroXiApXw4ZJa771Nt9xCcH42/AJ9Tka45B/nlF7rqcPPywsjR95t
cac77D8VJbZHj7oulvWdsks/elbs0Q6v0mkmxYu88lMaeXDR2DTaw1lyrF7H0zuY
MBgH/7JRqdQ59zh2iQ3GwAlS8eC4ACVOhMihWsBxNEsk2/WlgBByRDGDX0GTyEGH
yMjPtAi5qcsg7IolWwWqrz4Ik9JibQIDAQABAoICAFVlAA9N2ZU7tq4845t3E5Hy
KYEg4RQNSFovF6ijVgnBuBWBrtGjjy0UYVzolrMq5w4ZaJwunXku4o6cUv1cQRw5
WmisFGyaVFPKYZYIVFtarlRns4lC1q23oib77O89bgREKaYZAa48x9b2Yx/3U22A
I8+W/U0bzLHjHdXkezbJnTiuaz6NewYJaT97qfH0hV6pBmYDmPbE0ZH7A+TaK8Ud
mx+uG95Z6ypff5qA9hdLVQ2YM/YVukX9N2U3Hu6JCn1clvm7UXCimY2W9J4pnYZn
OsN6HgUHkAZWnuX8To98D9hiuRRrXCFi4MiksJlTvaZe4xlxEyZPc8Ch8N0jLOPL
Yp0RXbtBhE8sFLVPI0DTfXmJluGu91nUBPM5yl/cf4V+FPL7vGE98TDPVdq+ryih
5ebOATi5zW7/WPRBL1A1dtlKvwl06ZsMZ5S6zFHjr4QO2XyJ3VAKwx6lYl5ezPfb
2p9ccq5esjAAl3d0EggtLI2Y5vnMlpWUG2euupNanHhOSGMemtQLrmLTLQEL5WMW
F5nKjKMMutTAHVZlWyPPP/PAXmJBBRS80G7z1+qLOy3pYqGLML5d0H6wduMwyfof
uC16FvW/RmWlhxOiz/RLJi6a8jMhSqZPZ0GVOgsE+3mH4qndv6rI1GKKtuSjA1fo
i8uEfGp3ty5DdGWFSFMVAoIBAQDjbLXbZJE4p5wb3a3Ijb36xZHyruSWOa2DxWue
oPeyeXo/uQq26wuJWNHlaqXGxCH8tJXKKB3tikdBZQrFzok4wHbD2cF1m56aFYQ9
3LAlheZmmr3LvxqY0hLg+5viIHFywafGQxSt/7qBTizu9F1WQ/XVd4r5mgq9BIre
uunImEfq+7/8Xz3uNHk2kir6WYvhSB+bmge7u4qw4hfrKGvgZkUudTaBQOBByqlB
gk8N9MtFJ7HPbSlpXNfodK+ZLnOgnpfZs27BUEenFHcnTMcX6cJkJsOgeMUuLFoM
a3mJoz0NR3fOiaNIgTfhpe7H6jT75vmcSFVXO7OvnHnbBzj/AoIBAQDLkFOSLc4d
lZWYBehyUEPUgTTSJRNy09TY9uaBLB7E67ue6Ey8SWdaq1YFI9dYj7UGgRalNGX5
jprli/kOfl+LY3CCq471qMFJWMGaVyzOUmqTfXXuIvDr5N0+/gc1LvejcR1dGOWG
BFFnNgrIqYkgNrBn7qKmHJ+DS4/r6fmGp6LWXB1IZb4A3+0N3AtFYEvATycd6+ho
C64CtXHjOyrD6D6yIV1GSqHofBogW2Lw2cPll6rkwBrjnQQWY4ttFPRMivOA22Kj
5UL5x+O1cAF1gF2rcQjfFbgqxQ4xLgAxs34ZEyTAMlKFRHMEf71PrwSRiVt3qpry
j5JN0qL/61iTAoIBAQC5KVNPEqwhwmUZUv0gojahK6ZOPhKiNMeO13dtqYTB7KGZ
rCCLGQdFhekurgvWru01ABpMgykKs2CcX5XLwwJ6EEkh3/LgvBj/PrFyZHGNu10B
AM+ySR9weOkh//jEvMFhO0ZL52W43NKOYIW473/msmI+sJuX6NEBX+dovCmHRmSX
buy6nxifDl36DjurpKh8fOovF9NgB6s9pHbw4PIju2BsGMaNqbJsHoJ7cYrHxByT
a2Qbi7cBr7Oh8Q7e2rENftIHT03HWoNcBw+UEbCvSYUZYW45AtsXYsjV/9LuOteE
LkHfCLTGXV6P+zdT0N3ekgl8MnA5G8SKIA4eQ90lAoIBAQDKGc5+8O8UPDC7MBJp
e/r7/hOdF6ZJeLp3dhm/4TfjNk+eIvAcd5wfTsAmdkEU8gg+HueGuZEMxWJPyDpL
A3iEgQNxGDbk+th7o50DSM15QiYBrKvq89HRwfVO1xH84VaHdIQ8q70k4yCWofbu
5jL4QpO9fBULapuL1Pdct30/DSwEOovwFuMfJzLJcc/W3xYWJf+mG1MwCXiHw/EA
MvvwaKHmZG2gnfRFRwEBYvnGOc3eIkhOt9N6a6dlOwtwDz/ExqefJTC3m6R1LNmM
h1lLeViGH8E5Cu0/uUiv1wXmUlg9ON5h2xRGr4Cp1ND1TcPxYjfnhQA1FgmhLiEa
iGP1AoIBAFhDurkr/U0DsNGm3Cn2+GlarvoYPsXmLYJnv5yTanfII7XyBGtys2/5
sH4mEh4hx2wxHR0fDPfu4XZ4/vIMw5gg70gWRqJUeDiPvKPWWZizexNAgUx9ngc3
MCyA67cZZQ9lk10cNdujm8gjFi+I19iV43kA657IKQSQoptv+XKN4Bfuk6w0mjY1
XM1ZCpZVO/nhNmQYpgjYOMYEZuUXVwdOZx1LZXDu5kBQO2zstHkWBIKRjxPJ+gCa
vdD/AU3gLNUbUEF2rVx5YcKDQftjAMrZNtJ8GeuUK2Aoi1k5EYMo8fwkQ35UixNo
R54V/WirfICHJ9siZ4WsJk7VRFbvuhk=
-----END PRIVATE KEY-----

`,
  cert: `-----BEGIN CERTIFICATE-----
MIIE2jCCAsKgAwIBAgIJAI+JJie9DC+TMA0GCSqGSIb3DQEBCwUAMBQxEjAQBgNV
BAMTCWxvY2FsaG9zdDAgFw0yMjEwMDgxMDA3MjlaGA8yMTIyMDkxNDEwMDcyOVow
FDESMBAGA1UEAxMJbG9jYWxob3N0MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIIC
CgKCAgEAtNdrmV/OyhFSQAo05TqAV+5s33f0/TcawZTj4WroRqz8sWdhZk42UhK7
YEvelAlACx8mliJX5hgrU13HWWyxQsTRTbivpCKV5LUjv2SzZ68lE6WRV6WqwFCa
cnztG47Hya+o3NtYEWRZzQuKWwf2DA6rUK96OQEuaaro53FDkdIwR2+RD6pQHuAf
C3Kwfh82tsC8EachqaLoSkoNQEAyjcfM9F8HAqdTgqYBp4qsA69EIRlmeF/k9s4r
4R2oNmXW37j2CN7HvYZd9RF/V+TlzVSovglTrtAnbK1lTFZuuuQPKIv6Va/pvMWX
Yr2xJkMDUW2C6RAHNVHBNvMh7ujyE3Affou2yrQzDuFC1hTzusYr16UKl7ANaIPA
+MhAx6ws2g+4nsD7sWgLU2yTjVDHKDaGzg+NitoA7OmWCs3NnItRpY7F30NYjvUU
oMaZiMIO0/qHeYenJWccFey+2C74tOiF7q6F4gKV8OGSWu+9TbfcQnB+NvwCfU5G
uOQf55Re66nDz8sLI0febXGnO+w/FSW2R4+6Lpb1nbJLP3pW7NEOr9JpJsWLvPJT
Gnlw0dg02sNZcqxex9M7mDAYB/+yUanUOfc4dokNxsAJUvHguAAlToTIoVrAcTRL
JNv1pYAQckQxg19Bk8hBh8jIz7QIuanLIOyKJVsFqq8+CJPSYm0CAwEAAaMtMCsw
FAYDVR0RBA0wC4IJbG9jYWxob3N0MBMGA1UdJQQMMAoGCCsGAQUFBwMBMA0GCSqG
SIb3DQEBCwUAA4ICAQAhTBoM/lPVF83iI+7bn+gzJyA9DD3sjgTFgM9cqyfWuemg
L/KMKCqaWO3FynGuig4mNArp589zR5+rVyZTa0mxevpxEvK2J+i5sIdzlcNKBJul
WB9UNvluuop/lrC+vugHcKXSUmZeVXhdyaoOEdjz3zzhC9n/ixaLXjl0HzikAt7O
gJgDdk/d4v0ybH67r/ZhT2n2UPWWO6T/H1jc/qNKJmvpHKhia76c4h5nNk+FpLwJ
getTEJPB2cV3kR/mpXkk66WHLi3QK83z6zRkhh4aarYQ1BU7D/W/RpQrfBKJyA5C
rUi4eQXjwdhr/Hs72tnLYQyXhOWL2vvA392eWKoy8WNsewNoOn7nYxAJv5D0zdJb
hernuFyr3CsZfvlPwUZvNI5oEEIu/Rhvhp7qna6Ujh8h95zjiW2khUpBRjno3oew
O6Hj04vqL7wrhO0gXsBfMkg4ECsTVqLGu3fFV2ZeUaDyKrOcNO8+gSAkbWy3LUAh
PoksgZB44l2C7I+B37uxjoN6AweaPv98+AkS/Mg792bFfY/ZF4xNMo8Y+HgSBS5C
xcqzmsQaDOjmf5q4mjxuaZIDxb3slwpR4vaAJqCcMWK8PXqHpTz2msImWhCNnXiy
GqfVp1GwG1kla18ts1d98QWyaWjbdveZp3HMWZzQY1xOzyUX4K4Ejhho5oNl4w==
-----END CERTIFICATE-----

`
};

// src/WebSocketServer.ts
var PolyHttpServer = class {
  constructor() {
    this.net = net.createServer();
    this.http = http.createServer();
    this.https = https.createServer(CERTIFICATE);
    this.net.on("connection", (socket) => {
      socket.once("data", (buffer) => {
        socket.pause();
        const server = buffer[0] === 22 ? this.https : this.http;
        socket.unshift(buffer);
        server.emit("connection", socket);
        server.on("close", () => {
          socket.destroy();
        });
        process.nextTick(() => socket.resume());
      });
    });
  }
  listen(port) {
    this.net.listen(port);
  }
  async close() {
    return new Promise((resolve3, reject) => {
      let numClosed = 0;
      const callback = (error) => {
        numClosed++;
        if (error !== void 0 && error.code !== "ERR_SERVER_NOT_RUNNING") {
          reject(error);
        } else if (numClosed === 3) {
          resolve3();
        }
      };
      this.net.close(callback);
      this.http.close(callback);
      this.https.close(callback);
    });
  }
  onRequest(listener) {
    this.http.on("request", listener(false));
    this.https.on("request", listener(true));
  }
  onUpgrade(listener) {
    this.http.on("upgrade", listener);
    this.https.on("upgrade", listener);
  }
  onError(listener) {
    this.net.on("error", listener);
    this.http.on("error", listener);
    this.https.on("error", listener);
  }
  onceListening(listener) {
    this.net.once("listening", () => {
      listener(this.net.address());
    });
  }
};
var WebSocketServer = class {
  constructor(portChoice) {
    this.polyHttpServer = new PolyHttpServer();
    this.webSocketServer = new import_ws.WebSocketServer({ noServer: true });
    this.msgQueue = [];
    this.dispatchToQueue = (msg) => {
      this.msgQueue.push(msg);
    };
    this.dispatch = this.dispatchToQueue;
    this.webSocketServer.on("connection", (webSocket, request) => {
      webSocket[util2.inspect.custom] = /* v8 ignore next */
      (_depth, options) => options.stylize("WebSocket", "special");
      this.dispatch({
        tag: "WebSocketConnected",
        webSocket,
        // `request.url` is always a string here, but the types says it can be undefined:
        // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/15808
        urlString: (
          /* v8 ignore next */
          request.url ?? "/"
        )
      });
      webSocket.on("message", (data) => {
        this.dispatch({
          tag: "WebSocketMessageReceived",
          webSocket,
          data
        });
      });
      webSocket.on("close", () => {
        this.dispatch({ tag: "WebSocketClosed", webSocket });
      });
      webSocket.on("error", (error) => {
        this.dispatch({
          tag: "WebSocketServerError",
          error: { tag: "OtherError", error }
        });
      });
    });
    this.polyHttpServer.onError((error) => {
      this.dispatch({
        tag: "WebSocketServerError",
        error: error.code === "EADDRINUSE" ? { tag: "PortConflict", portChoice, error } : (
          /* v8 ignore next */
          { tag: "OtherError", error }
        )
      });
    });
    this.polyHttpServer.onRequest((isHttps) => (request, response) => {
      response.end(html(isHttps, request));
    });
    this.polyHttpServer.onUpgrade((request, socket, head) => {
      this.webSocketServer.handleUpgrade(request, socket, head, (webSocket) => {
        this.webSocketServer.emit("connection", webSocket, request);
      });
    });
    this.port = markAsPort(0);
    this.listening = new Promise((resolve3) => {
      this.polyHttpServer.onceListening((address) => {
        this.port = markAsPort(address.port);
        resolve3();
      });
    });
    this.polyHttpServer.listen(
      // If `port` is 0, the operating system will assign an arbitrary unused port.
      portChoice.tag === "NoPort" ? 0 : portChoice.port
    );
  }
  setDispatch(dispatch) {
    this.dispatch = dispatch;
    for (const msg of this.msgQueue) {
      dispatch(msg);
    }
  }
  unsetDispatch() {
    this.dispatch = this.dispatchToQueue;
  }
  async close() {
    this.unsetDispatch();
    this.webSocketServer.close();
    await this.polyHttpServer.close();
    for (const webSocket of this.webSocketServer.clients) {
      webSocket.close();
    }
  }
};
function html(isHttps, request) {
  const { host, referer } = request.headers;
  return `
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>elm-watch</title>
    <style>
      html {
        font-family: system-ui, sans-serif;
      }
    </style>
  </head>
  <body>
    <p>\u2139\uFE0F This is the elm-watch WebSocket server.</p>
    ${request.url === "/accept" ? isHttps ? `<p>\u2705 Certificate accepted. You may now ${maybeLink(
    referer !== void 0 && new URL(referer).host !== host ? referer : void 0,
    "return to your page"
  )}.</p>` : `<p>Did you mean to go to the ${maybeLink(
    /* v8 ignore start */
    host !== void 0 ? `https://${host}${request.url}` : void 0,
    "HTTPS version of this page"
  )} to accept elm-watch's self-signed certificate?</p>` : `<p>There's nothing interesting to see here: <a href="https://lydell.github.io/elm-watch/getting-started/#your-responsibilities">elm-watch is not a file server</a>.</p>`}
  </body>
</html>
  `.trim();
}
function maybeLink(href, text2) {
  return href === void 0 ? text2 : `<a href="${href}">${text2}</a>`;
}

// src/Hot.ts
async function run(env, logger, getNow, restartReasons, postprocessWorkerPool, webSocketState, webSocketToken, project, portChoice, hotKillManager) {
  const exitOnError = __ELM_WATCH_EXIT_ON_ERROR in env;
  const result = await runTeaProgram({
    initMutable: initMutable(
      env,
      logger,
      getNow,
      postprocessWorkerPool,
      webSocketState,
      webSocketToken,
      project,
      portChoice,
      hotKillManager
    ),
    init: init2(getNow(), restartReasons, project.elmJsonsErrors),
    update: (msg, model) => {
      const [newModel, cmds] = update(
        logger.config,
        project,
        exitOnError,
        msg,
        model
      );
      const allCmds = [
        ...cmds,
        newModel.latestEvents.length > model.latestEvents.length ? {
          tag: "SleepBeforeNextAction",
          sleepMs: getNextActionSleepMs(newModel.latestEvents)
        } : { tag: "NoCmd" }
      ];
      logger.debug(msg.tag, msg, newModel, allCmds);
      return [newModel, allCmds];
    },
    runCmd: runCmd(env, logger, getNow, exitOnError, webSocketToken)
  });
  hotKillManager.kill = void 0;
  return result;
}
async function watchElmWatchJsonOnce(getNow, elmWatchJsonPath) {
  return new Promise((resolve3, reject) => {
    const watcher = chokidar.watch(elmWatchJsonPath, {
      ignoreInitial: true,
      disableGlobbing: true
    });
    watcherOnAll(watcher, reject, (eventName, absolutePathString) => {
      const event = {
        tag: "WatcherEvent",
        date: getNow(),
        eventName,
        file: markAsAbsolutePath(absolutePathString)
      };
      watcher.close().then(() => {
        resolve3(event);
      }).catch(reject);
    });
  });
}
var initMutable = (env, logger, getNow, postprocessWorkerPool, webSocketState, webSocketToken, project, portChoice, hotKillManager) => (dispatch, resolvePromise, rejectPromise) => {
  const workerLimitTimeoutMs = silentlyReadIntEnvValue(
    env[__ELM_WATCH_WORKER_LIMIT_TIMEOUT_MS],
    1e4
  );
  const watcher = chokidar.watch(Array.from(project.watchRoots), {
    ignoreInitial: true,
    // Note: Forward slashes must be used here even on Windows. (Using
    // backslashes on Windows never matches.) The trailing slash is important:
    // It makes it possible to get notifications of a removed elm-stuff
    // folder, while ignoring everything that happens _inside_ that folder.
    // For `.stack-work/`, see https://docs.haskellstack.org/en/stable/topics/stack_work/ and
    // https://github.com/lydell/elm-watch/issues/106.
    ignored: /\/(elm-stuff|node_modules|\.stack-work)\//,
    disableGlobbing: true
  });
  watcherOnAll(
    watcher,
    (error) => {
      closeAll(logger, mutable).then(() => {
        resolvePromise({
          tag: "ExitOnHandledFatalError",
          errorTemplate: watcherError(error)
        });
      }).catch(rejectPromise);
    },
    (eventName, absolutePath) => {
      dispatch({
        tag: "GotWatcherEvent",
        date: getNow(),
        eventName,
        absolutePath
      });
    }
  );
  const {
    webSocketServer = new WebSocketServer(portChoice),
    webSocketConnections = []
  } = webSocketState ?? {};
  const mutable = {
    watcher,
    postprocessWorkerPool,
    webSocketServer,
    webSocketConnections,
    lastWebSocketCloseTimestamp: void 0,
    workerLimitTimeoutMs,
    workerLimitTimeoutId: void 0,
    project,
    lastInfoMessage: void 0,
    watcherTimeoutId: void 0,
    elmWatchStuffJsonWriteError: void 0,
    killInstallDependencies: void 0
  };
  webSocketServer.setDispatch((msg) => {
    onWebSocketServerMsg(
      getNow(),
      logger,
      mutable,
      webSocketToken,
      dispatch,
      resolvePromise,
      rejectPromise,
      msg
    );
  });
  postprocessWorkerPool.setCalculateMax(
    () => mutable.lastWebSocketCloseTimestamp !== void 0 && getNow().getTime() >= mutable.lastWebSocketCloseTimestamp + workerLimitTimeoutMs ? (
      // Save one worker, so we always have one “warmed up” worker ready to go
      // when needed.
      Math.max(1, makePrioritizedOutputs(mutable.webSocketConnections).size)
    ) : Infinity
  );
  webSocketServer.listening.then(() => {
    writeElmWatchStuffJson(mutable, webSocketToken);
  }).catch(rejectPromise);
  const kill = async () => {
    try {
      if (mutable.killInstallDependencies !== void 0) {
        mutable.killInstallDependencies({ force: true });
      }
      await Promise.all(
        getFlatOutputs(project).map(
          ({ outputState }) => "kill" in outputState.status ? outputState.status.kill({ force: true }) : Promise.resolve()
        )
      );
      await closeAll(logger, mutable);
    } catch (unknownError) {
      const error = toError(unknownError);
      rejectPromise(toError(error));
    }
    hotKillManager.kill = void 0;
  };
  hotKillManager.kill = async () => {
    dispatch({ tag: "ExitRequested", date: getNow() });
    await kill();
    resolvePromise({ tag: "ExitOnIdle", reason: "Other" });
  };
  logger.setRawMode(() => {
    kill().then(() => {
      resolvePromise({
        tag: "ExitOnIdle",
        reason: "CtrlCPressedOrStdinEnd"
      });
    }).catch(rejectPromise);
  });
  return mutable;
};
function writeElmWatchStuffJson(mutable, webSocketToken) {
  const targets = Object.fromEntries([
    ...mutable.project.elmJsonsErrors.map(
      (error) => [
        error.outputPath.targetName,
        {
          compilationMode: error.compilationMode,
          browserUiPosition: error.browserUiPosition,
          openErrorOverlay: error.openErrorOverlay
        }
      ]
    ),
    ...getFlatOutputs(mutable.project).map(
      ({ outputPath, outputState }) => [
        outputPath.targetName,
        {
          compilationMode: outputState.compilationMode,
          browserUiPosition: outputState.browserUiPosition,
          openErrorOverlay: outputState.openErrorOverlay
        }
      ]
    )
  ]);
  const json2 = {
    port: mutable.webSocketServer.port,
    webSocketToken,
    targets
  };
  try {
    fs7.mkdirSync(absoluteDirname(mutable.project.elmWatchStuffJsonPath), {
      recursive: true
    });
    fs7.writeFileSync(
      mutable.project.elmWatchStuffJsonPath,
      `${Codec16.JSON.stringify(ElmWatchStuffJson, json2, 4)}
`
    );
    mutable.elmWatchStuffJsonWriteError = void 0;
  } catch (unknownError) {
    const error = toError(unknownError);
    mutable.elmWatchStuffJsonWriteError = error;
  }
}
function watcherOnAll(watcher, onError, onSuccess) {
  watcher.on("all", (chokidarEventName, absolutePathString) => {
    const absolutePath = markAsAbsolutePath(absolutePathString);
    switch (chokidarEventName) {
      case "add":
      case "addDir":
        onSuccess("added", absolutePath);
        return;
      case "unlink":
      case "unlinkDir":
        onSuccess("removed", absolutePath);
        return;
      case "change":
        onSuccess("changed", absolutePath);
        return;
    }
  });
  watcher.on("error", onError);
}
var init2 = (now, restartReasons, elmJsonsErrors) => [
  {
    nextAction: { tag: "NoAction" },
    hotState: {
      tag: "Dependencies",
      start: now
    },
    latestEvents: restartReasons
  },
  [
    { tag: "ClearScreen" },
    { tag: "InstallDependencies" },
    ...elmJsonsErrors.map(
      (elmJsonError) => ({
        tag: "WebSocketSendToOutput",
        outputPath: elmJsonError.outputPath,
        message: {
          tag: "StatusChanged",
          status: {
            tag: "ElmJsonError",
            error: toPlainString(
              renderElmJsonError(elmJsonError)
            )
          }
        }
      })
    )
  ]
];
function update(loggerConfig, project, exitOnError, msg, model) {
  switch (msg.tag) {
    case "GotWatcherEvent": {
      const result = onWatcherEvent(
        msg.date,
        project,
        msg.eventName,
        msg.absolutePath,
        model.nextAction
      );
      if (result === void 0) {
        return [model, []];
      }
      const [updatedNextAction, latestEvent, cmds] = result;
      return [
        {
          ...model,
          nextAction: updatedNextAction,
          latestEvents: [...model.latestEvents, latestEvent]
        },
        cmds
      ];
    }
    case "ExitRequested":
      if (model.hotState.tag !== "Idle") {
        return [
          model,
          [
            {
              tag: "Throw",
              error: new Error(
                `Got ExitRequested. Expected hotState to be Idle but it is: ${model.hotState.tag}`
              )
            }
          ]
        ];
      }
      switch (model.nextAction.tag) {
        /* v8 ignore start */
        case "Restart":
        case "Compile":
          return [
            model,
            [
              {
                tag: "Throw",
                error: new Error(
                  `Got ExitRequested. Expected nextAction to be NoAction but it is: ${model.nextAction.tag}`
                )
              }
            ]
          ];
        /* v8 ignore end */
        case "NoAction":
          return runNextAction(msg.date, project, model);
      }
    case "SleepBeforeNextActionDone": {
      const [newModel, cmds] = runNextAction(msg.date, project, model);
      return [
        {
          ...newModel,
          nextAction: { tag: "NoAction" }
        },
        cmds
      ];
    }
    case "CompilationPartDone": {
      const includeInterrupted = model.nextAction.tag !== "Compile";
      const outputActions = getOutputActions({
        project,
        runMode: "hot",
        includeInterrupted,
        prioritizedOutputs: msg.prioritizedOutputs
      });
      switch (model.hotState.tag) {
        /* v8 ignore start */
        case "Dependencies":
        case "Idle":
          return [
            model,
            [
              {
                tag: "Throw",
                error: new Error(
                  `HotState became ${model.hotState.tag} while compiling!`
                )
              }
            ]
          ];
        /* v8 ignore stop */
        case "Compiling": {
          const duration = msg.date.getTime() - model.hotState.start.getTime();
          const cmd = handleOutputActionResultToCmd(
            project.elmWatchJsonPath,
            msg.handleOutputActionResult
          );
          if (isNonEmptyArray(outputActions.actions)) {
            return [
              model,
              [
                cmd,
                {
                  tag: "CompileAllOutputsAsNeeded",
                  mode: "ContinueCompilation",
                  includeInterrupted
                }
              ]
            ];
          }
          if (outputActions.numExecuting > 0 || outputActions.numInterrupted > 0) {
            return [model, [cmd]];
          }
          const errors = extractErrors(project);
          return [
            { ...model, hotState: { tag: "Idle" }, latestEvents: [] },
            [
              cmd,
              isNonEmptyArray(errors) ? { tag: "PrintCompileErrors", errors } : { tag: "NoCmd" },
              { tag: "HandleElmWatchStuffJsonWriteError" },
              {
                tag: "LogInfoMessageWithTimeline",
                message: compileFinishedMessage(loggerConfig, duration),
                events: model.latestEvents
              },
              isNonEmptyArray(errors) && exitOnError ? { tag: "ExitOnIdle" } : { tag: "NoCmd" }
            ]
          ];
        }
        case "Restarting":
          return outputActions.numExecuting === 0 ? [model, [{ tag: "Restart", restartReasons: model.latestEvents }]] : [model, []];
      }
    }
    case "InstallDependenciesDone":
      switch (model.hotState.tag) {
        case "Dependencies": {
          switch (msg.installResult.tag) {
            case "Error":
              return [
                { ...model, hotState: { tag: "Idle" } },
                /* v8 ignore next */
                [exitOnError ? { tag: "ExitOnIdle" } : { tag: "NoCmd" }]
              ];
            // We only kill installing dependencies when a restart is needed.
            // Wait for the restart to happen.
            case "Killed":
              return [{ ...model, hotState: { tag: "Idle" } }, []];
            case "Success": {
              return [
                {
                  ...model,
                  hotState: {
                    tag: "Compiling",
                    start: model.hotState.start
                  }
                },
                [
                  {
                    tag: "CompileAllOutputsAsNeeded",
                    mode: "AfterInstallDependencies",
                    includeInterrupted: true
                  }
                ]
              ];
            }
          }
        }
        case "Restarting":
          return [
            model,
            [{ tag: "Restart", restartReasons: model.latestEvents }]
          ];
        /* v8 ignore start */
        case "Idle":
        case "Compiling":
          return [
            model,
            [
              {
                tag: "Throw",
                error: new Error(
                  `HotState became ${model.hotState.tag} while installing dependencies!`
                )
              }
            ]
          ];
      }
    case "WebSocketClosed":
      return [
        {
          ...model,
          latestEvents: [
            ...model.latestEvents,
            {
              tag: "WebSocketClosed",
              date: msg.date,
              outputPath: msg.outputPath
            }
          ]
        },
        []
      ];
    case "WebSocketConnected": {
      const result = msg.parseWebSocketConnectRequestUrlResult;
      switch (result.tag) {
        case "Success": {
          const [newModel, latestEvent, cmds] = onWebSocketConnected(
            msg.date,
            model,
            project.elmWatchJsonPath,
            result.elmJsonPath,
            result.outputPath,
            result.outputState,
            result.elmCompiledTimestamp
          );
          return [
            {
              ...newModel,
              latestEvents: [...newModel.latestEvents, latestEvent]
            },
            cmds
          ];
        }
        case "ElmJsonError": {
          const elmJsonError = result.error;
          const event = {
            tag: "WebSocketConnectedNeedingNoAction",
            date: msg.date,
            outputPath: elmJsonError.outputPath
          };
          return [
            {
              ...model,
              latestEvents: [...model.latestEvents, event]
            },
            [
              {
                tag: "WebSocketSendToOutput",
                outputPath: elmJsonError.outputPath,
                message: {
                  tag: "StatusChanged",
                  status: {
                    tag: "ElmJsonError",
                    error: toPlainString(
                      renderElmJsonError(elmJsonError)
                    )
                  }
                }
              }
            ]
          ];
        }
        default:
          return [
            {
              ...model,
              latestEvents: [
                ...model.latestEvents,
                {
                  tag: "WebSocketConnectedWithErrors",
                  date: msg.date
                }
              ]
            },
            [
              {
                tag: "WebSocketSend",
                webSocket: msg.webSocket,
                message: {
                  tag: "StatusChanged",
                  status: {
                    tag: "ClientError",
                    message: webSocketConnectRequestUrlErrorToString(result)
                  }
                }
              }
            ]
          ];
      }
    }
    case "WebSocketMessageReceived": {
      const result = parseWebSocketToServerMessage(msg.data);
      switch (result.tag) {
        case "Success":
          return onWebSocketToServerMessage(
            project.elmWatchJsonPath,
            model,
            msg.date,
            msg.output,
            msg.webSocket,
            result.message
          );
        case "DecoderError":
          return [
            model,
            [
              {
                tag: "WebSocketSend",
                webSocket: msg.webSocket,
                message: {
                  tag: "StatusChanged",
                  status: {
                    tag: "ClientError",
                    message: webSocketDecodeError(result.error)
                  }
                }
              }
            ]
          ];
      }
    }
    case "WorkerLimitTimeoutPassed":
      return [model, [{ tag: "LimitWorkers" }]];
    case "WorkersLimited":
      return [
        {
          ...model,
          latestEvents: [
            ...model.latestEvents,
            {
              tag: "WorkersLimitedAfterWebSocketClosed",
              date: msg.date,
              numTerminatedWorkers: msg.numTerminatedWorkers
            }
          ]
        },
        []
      ];
  }
}
function onWatcherEvent(now, project, eventName, absolutePath, nextAction) {
  if (absolutePath.endsWith(".elm")) {
    return onElmFileWatcherEvent(
      project,
      makeWatcherEvent(eventName, absolutePath, now),
      nextAction
    );
  }
  const basename2 = path8.basename(absolutePath);
  switch (basename2) {
    case "elm-watch.json":
      switch (eventName) {
        case "added":
          return makeRestartNextAction(
            makeWatcherEvent(eventName, absolutePath, now),
            project
          );
        case "changed":
        case "removed":
          if (absolutePath === project.elmWatchJsonPath) {
            return makeRestartNextAction(
              makeWatcherEvent(eventName, absolutePath, now),
              project
            );
          }
          return void 0;
      }
    case "elm.json":
      switch (eventName) {
        case "added":
          return makeRestartNextAction(
            makeWatcherEvent(eventName, absolutePath, now),
            project
          );
        case "changed":
        case "removed":
          if (Array.from(project.elmJsons).some(
            ([elmJsonPath]) => absolutePath === elmJsonPath
          ) || isElmJsonFileRelatedToElmJsonsErrors(
            absolutePath,
            project.elmJsonsErrors
          )) {
            return makeRestartNextAction(
              makeWatcherEvent(eventName, absolutePath, now),
              project
            );
          }
          return void 0;
      }
    // Some compiler error messages suggest removing elm-stuff to fix the error.
    // Restart when that happens. Note: This could be a totally unrelated
    // elm-stuff directory, but I don’t think it’s worth the trouble trying to
    // check if it affects the project, and possibly logging if it isn’t.
    case "elm-stuff":
      switch (eventName) {
        case "removed":
          return makeRestartNextAction(
            makeWatcherEvent(eventName, absolutePath, now),
            project
          );
        default:
          return void 0;
      }
    default:
      return absolutePath === getPostprocessElmWatchNodeScriptPath(project) ? [
        compileNextAction(nextAction),
        {
          ...makeWatcherEvent(eventName, absolutePath, now),
          affectsAnyTarget: true
        },
        [
          {
            tag: "MarkAsDirty",
            outputs: getFlatOutputs(project),
            killInstallDependencies: false
          },
          { tag: "RestartWorkers" }
        ]
      ] : (
        // Ignore other types of files.
        void 0
      );
  }
}
function onElmFileWatcherEvent(project, event, nextAction) {
  const elmFile = event.file;
  if (isElmFileRelatedToElmJsonsErrors(elmFile, project.elmJsonsErrors)) {
    return makeRestartNextAction(event, project);
  }
  const dirtyOutputs = [];
  for (const [elmJsonPath, outputs] of project.elmJsons) {
    for (const [outputPath, outputState] of outputs) {
      if (event.eventName === "removed") {
        for (const inputPath of outputState.inputs) {
          if (equalsInputPath(elmFile, inputPath)) {
            return makeRestartNextAction(event, project);
          }
        }
      }
      ensureAllRelatedElmFilePaths(elmJsonPath, outputState);
      if (outputState.allRelatedElmFilePaths.has(elmFile)) {
        dirtyOutputs.push({ outputPath, outputState });
      }
    }
  }
  return isNonEmptyArray(dirtyOutputs) ? [
    compileNextAction(nextAction),
    { ...event, affectsAnyTarget: true },
    [
      {
        tag: "MarkAsDirty",
        outputs: dirtyOutputs,
        killInstallDependencies: false
      }
    ]
  ] : [nextAction, { ...event, affectsAnyTarget: false }, []];
}
function runNextAction(start, project, model) {
  switch (model.nextAction.tag) {
    case "Restart":
      switch (model.hotState.tag) {
        case "Idle":
          return [
            { ...model, hotState: { tag: "Restarting" } },
            [
              { tag: "ClearScreen" },
              { tag: "Restart", restartReasons: model.latestEvents }
            ]
          ];
        case "Dependencies":
        case "Compiling": {
          return [{ ...model, hotState: { tag: "Restarting" } }, []];
        }
        /* v8 ignore start */
        case "Restarting":
          return [model, []];
      }
    case "Compile":
      switch (model.hotState.tag) {
        case "Idle": {
          return [
            {
              ...model,
              hotState: { tag: "Compiling", start }
            },
            [
              {
                tag: "CompileAllOutputsAsNeeded",
                mode: "AfterIdle",
                includeInterrupted: true
              }
            ]
          ];
        }
        case "Compiling":
          return [
            model,
            [
              {
                tag: "CompileAllOutputsAsNeeded",
                mode: "ContinueCompilation",
                includeInterrupted: true
              }
            ]
          ];
        /* v8 ignore start */
        case "Dependencies":
        case "Restarting":
          return [model, []];
      }
    case "NoAction":
      switch (model.hotState.tag) {
        case "Idle":
          return isNonEmptyArray(model.latestEvents) ? [
            { ...model, latestEvents: [] },
            [
              {
                tag: "LogInfoMessageWithTimeline",
                message: printEventsMessage(
                  model.latestEvents,
                  project.disabledOutputs
                ),
                events: model.latestEvents
              }
            ]
          ] : [model, []];
        case "Compiling":
        case "Dependencies":
        case "Restarting":
          return [model, []];
      }
  }
}
var runCmd = (env, logger, getNow, exitOnError, webSocketToken) => (cmd, mutable, dispatch, resolvePromise, rejectPromise) => {
  switch (cmd.tag) {
    case "ChangeBrowserUiPosition":
      cmd.outputState.browserUiPosition = cmd.browserUiPosition;
      writeElmWatchStuffJson(mutable, webSocketToken);
      return;
    case "ChangeCompilationMode":
      cmd.outputState.compilationMode = cmd.compilationMode;
      writeElmWatchStuffJson(mutable, webSocketToken);
      return;
    case "ChangeOpenErrorOverlay":
      cmd.outputState.openErrorOverlay = cmd.openErrorOverlay;
      writeElmWatchStuffJson(mutable, webSocketToken);
      return;
    case "ClearScreen":
      logger.clearScreen();
      mutable.lastInfoMessage = void 0;
      return;
    case "CompileAllOutputsAsNeeded": {
      const outputActions = getOutputActions({
        project: mutable.project,
        runMode: "hot",
        includeInterrupted: cmd.includeInterrupted,
        prioritizedOutputs: makePrioritizedOutputs(
          mutable.webSocketConnections
        )
      });
      switch (cmd.mode) {
        case "AfterInstallDependencies":
          printStatusLinesForElmJsonsErrors(logger, mutable.project);
          printSpaceForOutputs(logger, "hot", outputActions);
          break;
        case "AfterIdle":
          logger.clearScreen();
          mutable.lastInfoMessage = void 0;
          printStatusLinesForElmJsonsErrors(logger, mutable.project);
          printSpaceForOutputs(logger, "hot", outputActions);
          break;
        case "ContinueCompilation":
          break;
      }
      if (isNonEmptyArray(outputActions.actions)) {
        for (const action of outputActions.actions) {
          handleOutputAction({
            env,
            logger,
            getNow,
            runMode: {
              tag: "hot",
              webSocketPort: mutable.webSocketServer.port,
              webSocketToken
            },
            elmWatchJsonPath: mutable.project.elmWatchJsonPath,
            total: outputActions.total,
            action,
            postprocess: mutable.project.postprocess,
            postprocessWorkerPool: mutable.postprocessWorkerPool
          }).then((handleOutputActionResult) => {
            dispatch({
              tag: "CompilationPartDone",
              date: getNow(),
              prioritizedOutputs: makePrioritizedOutputs(
                mutable.webSocketConnections
              ),
              handleOutputActionResult
            });
          }).catch(rejectPromise);
        }
      } else if (outputActions.numExecuting === 0) {
        dispatch({
          tag: "CompilationPartDone",
          date: getNow(),
          prioritizedOutputs: makePrioritizedOutputs(
            mutable.webSocketConnections
          ),
          handleOutputActionResult: { tag: "Nothing" }
        });
      }
      return;
    }
    case "HandleElmWatchStuffJsonWriteError":
      if (mutable.elmWatchStuffJsonWriteError !== void 0) {
        writeElmWatchStuffJson(mutable, webSocketToken);
        if (mutable.elmWatchStuffJsonWriteError !== void 0) {
          logger.write("");
          logger.errorTemplate(
            elmWatchStuffJsonWriteError(
              mutable.project.elmWatchStuffJsonPath,
              mutable.elmWatchStuffJsonWriteError
            )
          );
          if (exitOnError) {
            closeAll(logger, mutable).then(() => {
              resolvePromise({ tag: "ExitOnIdle", reason: "Other" });
            }).catch(rejectPromise);
          }
        }
      }
      return;
    case "InstallDependencies": {
      mutable.webSocketServer.listening.then(() => {
        const { promise, kill } = installDependencies(
          env,
          logger,
          getNow,
          mutable.project
        );
        mutable.killInstallDependencies = ({ force }) => {
          kill({ force });
          mutable.killInstallDependencies = void 0;
        };
        return promise;
      }).finally(() => {
        mutable.killInstallDependencies = void 0;
      }).then((installResult) => {
        dispatch({
          tag: "InstallDependenciesDone",
          date: getNow(),
          installResult
        });
      }).catch(rejectPromise);
      return;
    }
    case "LimitWorkers":
      mutable.postprocessWorkerPool.limit().then((numTerminatedWorkers) => {
        if (numTerminatedWorkers > 0) {
          dispatch({
            tag: "WorkersLimited",
            date: getNow(),
            numTerminatedWorkers
          });
        }
      }).catch(rejectPromise);
      return;
    case "LogInfoMessageWithTimeline": {
      if (mutable.lastInfoMessage !== void 0) {
        logger.moveCursor(0, -mutable.lastInfoMessage.split("\n").length);
        logger.clearScreenDown();
      }
      const fullMessage = infoMessageWithTimeline({
        loggerConfig: logger.config,
        date: getNow(),
        mutable,
        message: cmd.message,
        events: filterLatestEvents(cmd.events),
        hasErrors: isNonEmptyArray(extractErrors(mutable.project))
      });
      logger.write(fullMessage);
      logger.clearScreenDown();
      mutable.lastInfoMessage = fullMessage;
      if (__ELM_WATCH_EXIT_ON_WORKER_LIMIT in env && cmd.events.some(
        (event) => event.tag === "WorkersLimitedAfterWebSocketClosed"
      )) {
        closeAll(logger, mutable).then(() => {
          resolvePromise({ tag: "ExitOnIdle", reason: "Other" });
        }).catch(rejectPromise);
      }
      return;
    }
    case "MarkAsDirty":
      if (cmd.killInstallDependencies && mutable.killInstallDependencies !== void 0) {
        mutable.killInstallDependencies({ force: false });
      }
      for (const { outputPath, outputState } of cmd.outputs) {
        outputState.dirty = true;
        if ("kill" in outputState.status) {
          Promise.resolve(outputState.status.kill({ force: false })).catch(
            rejectPromise
          );
        }
        webSocketSendToOutput(
          outputPath,
          {
            tag: "StatusChanged",
            status: {
              tag: "Busy",
              compilationMode: outputState.compilationMode,
              browserUiPosition: outputState.browserUiPosition
            }
          },
          mutable.webSocketConnections
        );
      }
      return;
    case "NoCmd":
      return;
    case "OpenEditor": {
      const command = env[ELM_WATCH_OPEN_EDITOR];
      if (command === void 0) {
        webSocketSend(cmd.webSocket, {
          tag: "OpenEditorFailed",
          error: { tag: "EnvNotSet" }
        });
      } else if (!projectHasFilePathThatCanBeOpenedInEditor(mutable.project, cmd.file)) {
        webSocketSend(cmd.webSocket, {
          tag: "OpenEditorFailed",
          error: {
            tag: "InvalidFilePath",
            message: openEditorInvalidFilePath(cmd.file)
          }
        });
      } else {
        const cwd = absoluteDirname(mutable.project.elmWatchJsonPath);
        const timeout = silentlyReadIntEnvValue(
          env[__ELM_WATCH_OPEN_EDITOR_TIMEOUT_MS],
          5e3
        );
        const extraEnv = {
          file: cmd.file,
          line: cmd.line.toString(),
          column: cmd.column.toString()
        };
        childProcess2.exec(
          command,
          {
            cwd,
            env: { ...env, ...extraEnv },
            encoding: "utf8",
            timeout
          },
          (error, stdout, stderr) => {
            if (error !== null) {
              webSocketSend(cmd.webSocket, {
                tag: "OpenEditorFailed",
                error: {
                  tag: "CommandFailed",
                  message: openEditorCommandFailed({
                    error,
                    command,
                    cwd,
                    timeout,
                    env: extraEnv,
                    stdout,
                    stderr
                  })
                }
              });
            }
          }
        );
      }
      return;
    }
    case "PrintCompileErrors":
      printErrors(logger, cmd.errors);
      return;
    case "Restart": {
      const elmWatchJsonChanged = cmd.restartReasons.some((event) => {
        switch (event.tag) {
          case "WatcherEvent":
            return path8.basename(event.file) === "elm-watch.json";
          /* v8 ignore start */
          default:
            return false;
        }
      });
      closeAll(logger, mutable, {
        killWebSocketServer: elmWatchJsonChanged,
        killPostprocessWorkerPool: elmWatchJsonChanged
      }).then(() => {
        resolvePromise({
          tag: "Restart",
          restartReasons: cmd.restartReasons,
          postprocessWorkerPool: mutable.postprocessWorkerPool,
          webSocketState: elmWatchJsonChanged ? void 0 : {
            webSocketServer: mutable.webSocketServer,
            webSocketConnections: mutable.webSocketConnections
          }
        });
      }).catch(rejectPromise);
      return;
    }
    case "RestartWorkers":
      mutable.postprocessWorkerPool.terminate().then(() => {
        mutable.postprocessWorkerPool.getOrCreateAvailableWorker();
      }).catch(rejectPromise);
      return;
    case "ExitOnIdle":
      closeAll(logger, mutable).then(() => {
        resolvePromise({ tag: "ExitOnIdle", reason: "Other" });
      }).catch(rejectPromise);
      return;
    case "SleepBeforeNextAction":
      if (mutable.watcherTimeoutId !== void 0) {
        clearTimeout(mutable.watcherTimeoutId);
      }
      mutable.watcherTimeoutId = setTimeout(() => {
        mutable.watcherTimeoutId = void 0;
        dispatch({ tag: "SleepBeforeNextActionDone", date: getNow() });
      }, cmd.sleepMs);
      return;
    /* v8 ignore start */
    case "Throw":
      rejectPromise(cmd.error);
      return;
    /* v8 ignore stop */
    case "WebSocketSend":
      webSocketSend(cmd.webSocket, cmd.message);
      return;
    case "WebSocketSendCompileErrorToOutput":
      getThemeFromTerminal(logger).then((theme) => {
        const message = {
          tag: "StatusChanged",
          status: {
            tag: "CompileError",
            compilationMode: cmd.compilationMode,
            browserUiPosition: cmd.browserUiPosition,
            openErrorOverlay: cmd.openErrorOverlay,
            errors: cmd.errors.map(
              (errorTemplate) => toHtml(errorTemplate, theme, logger.config.noColor)
            ),
            foregroundColor: theme.foreground,
            backgroundColor: theme.background
          }
        };
        webSocketSendToOutput(
          cmd.outputPath,
          message,
          mutable.webSocketConnections
        );
      }).catch(rejectPromise);
      return;
    case "WebSocketSendToOutput":
      webSocketSendToOutput(
        cmd.outputPath,
        cmd.message,
        mutable.webSocketConnections
      );
      return;
    case "WebSocketUpdatePriority":
      for (const webSocketConnection of mutable.webSocketConnections) {
        if (webSocketConnection.webSocket === cmd.webSocket) {
          webSocketConnection.priority = getNow().getTime();
        }
      }
      return;
  }
};
function onWebSocketServerMsg(now, logger, mutable, webSocketToken, dispatch, resolvePromise, rejectPromise, msg) {
  switch (msg.tag) {
    case "WebSocketConnected": {
      const result = parseWebSocketConnectRequestUrl(
        mutable.project,
        webSocketToken,
        msg.urlString
      );
      const webSocketConnection = {
        webSocket: msg.webSocket,
        outputPath: webSocketConnectRequestUrlResultToOutputPath(result),
        priority: now.getTime()
      };
      mutable.webSocketConnections.push(webSocketConnection);
      dispatch({
        tag: "WebSocketConnected",
        date: now,
        parseWebSocketConnectRequestUrlResult: result,
        webSocket: msg.webSocket
      });
      return;
    }
    case "WebSocketClosed": {
      const removedConnection = mutable.webSocketConnections.find(
        (connection) => connection.webSocket === msg.webSocket
      );
      mutable.webSocketConnections = mutable.webSocketConnections.filter(
        (connection) => connection.webSocket !== msg.webSocket
      );
      mutable.lastWebSocketCloseTimestamp = now.getTime();
      if (mutable.workerLimitTimeoutId !== void 0) {
        clearTimeout(mutable.workerLimitTimeoutId);
      }
      mutable.workerLimitTimeoutId = setTimeout(() => {
        mutable.workerLimitTimeoutId = void 0;
        dispatch({ tag: "WorkerLimitTimeoutPassed" });
      }, mutable.workerLimitTimeoutMs);
      dispatch({
        tag: "WebSocketClosed",
        date: now,
        outputPath: (
          /* v8 ignore start */
          removedConnection === void 0 ? { tag: "OutputPathError" } : removedConnection.outputPath
        )
        /* v8 ignore stop */
      });
      return;
    }
    case "WebSocketMessageReceived": {
      const webSocketConnection = mutable.webSocketConnections.find(
        ({ webSocket }) => webSocket === msg.webSocket
      );
      if (webSocketConnection === void 0) {
        rejectPromise(
          new Error(
            `No web socket connection found for web socket message ${quote(
              msg.tag
            )}`
          )
        );
        return;
      }
      const flatOutputs = getFlatOutputs(mutable.project);
      const output = flatOutputs.find(
        ({ outputPath }) => webSocketConnectionIsForOutputPath(webSocketConnection, outputPath)
      );
      dispatch({
        tag: "WebSocketMessageReceived",
        date: now,
        output: output === void 0 ? { tag: "OutputPathError" } : { tag: "Output", ...output },
        webSocket: msg.webSocket,
        data: msg.data
      });
      return;
    }
    case "WebSocketServerError":
      switch (msg.error.tag) {
        case "PortConflict": {
          const { portChoice } = msg.error;
          closeAll(logger, mutable).then(() => {
            resolvePromise({
              tag: "ExitOnHandledFatalError",
              errorTemplate: portChoiceError(
                mutable.project,
                portChoice,
                msg.error.error
              )
            });
          }).catch(rejectPromise);
          return;
        }
        /* v8 ignore start */
        case "OtherError":
          rejectPromise(msg.error.error);
          return;
      }
  }
}
function portChoiceError(project, portChoice, error) {
  switch (portChoice.tag) {
    /* v8 ignore start */
    case "NoPort":
      return portConflictForNoPort(error);
    /* v8 ignore stop */
    case "PersistedPort":
      return portConflictForPersistedPort(
        project.elmWatchStuffJsonPath,
        portChoice.port
      );
    case "PortFromConfig":
      return portConflictForPortFromConfig(
        project.elmWatchJsonPath,
        portChoice.port
      );
  }
}
function handleOutputActionResultToCmd(elmWatchJsonPath, handleOutputActionResult) {
  switch (handleOutputActionResult.tag) {
    case "CompileError":
      return {
        tag: "WebSocketSendCompileErrorToOutput",
        outputPath: handleOutputActionResult.outputPath,
        compilationMode: handleOutputActionResult.outputState.compilationMode,
        browserUiPosition: handleOutputActionResult.outputState.browserUiPosition,
        openErrorOverlay: handleOutputActionResult.outputState.openErrorOverlay,
        errors: renderOutputErrors(
          elmWatchJsonPath,
          handleOutputActionResult.elmJsonPath,
          handleOutputActionResult.outputPath,
          handleOutputActionResult.outputState.status
        )
      };
    case "FullyCompiledJS":
      return {
        tag: "WebSocketSendToOutput",
        outputPath: handleOutputActionResult.outputPath,
        message: {
          tag: "SuccessfullyCompiled",
          code: handleOutputActionResult.code.toString("utf8"),
          elmCompiledTimestamp: handleOutputActionResult.elmCompiledTimestamp,
          compilationMode: handleOutputActionResult.outputState.compilationMode,
          browserUiPosition: handleOutputActionResult.outputState.browserUiPosition
        }
      };
    case "FullyCompiledJSButRecordFieldsChanged":
      return {
        tag: "WebSocketSendToOutput",
        outputPath: handleOutputActionResult.outputPath,
        message: { tag: "SuccessfullyCompiledButRecordFieldsChanged" }
      };
    case "Nothing":
      return { tag: "NoCmd" };
  }
}
async function closeAll(logger, mutable, { killWebSocketServer = true, killPostprocessWorkerPool = true } = {}) {
  logger.reset();
  if (mutable.workerLimitTimeoutId !== void 0) {
    clearTimeout(mutable.workerLimitTimeoutId);
  }
  if (mutable.watcherTimeoutId !== void 0) {
    clearTimeout(mutable.watcherTimeoutId);
  }
  mutable.webSocketServer.unsetDispatch();
  await Promise.all([
    mutable.watcher.close(),
    killWebSocketServer ? mutable.webSocketServer.close() : void 0,
    killPostprocessWorkerPool ? mutable.postprocessWorkerPool.terminate() : void 0
  ]);
}
function makePrioritizedOutputs(webSocketConnections) {
  const map = /* @__PURE__ */ new Map();
  for (const { outputPath, priority } of webSocketConnections) {
    if (outputPath.tag !== "OutputPathError") {
      const previous = map.get(outputPath.targetName) ?? 0;
      map.set(outputPath.targetName, Math.max(priority, previous));
    }
  }
  return map;
}
function makeWatcherEvent(eventName, absolutePath, date) {
  return {
    tag: "WatcherEvent",
    date,
    eventName,
    file: absolutePath
  };
}
function makeRestartNextAction(event, project) {
  return [
    { tag: "Restart" },
    { ...event, affectsAnyTarget: true },
    [
      {
        // Interrupt all compilation.
        tag: "MarkAsDirty",
        outputs: getFlatOutputs(project),
        killInstallDependencies: true
      }
    ]
  ];
}
function isElmFileRelatedToElmJsonsErrors(elmFile, elmJsonsErrors) {
  return elmJsonsErrors.some(({ error }) => {
    switch (error.tag) {
      case "DuplicateInputs":
        return error.duplicates.some(
          ({ inputs, resolved }) => resolved === elmFile || inputs.some((inputPath) => equalsInputPath(elmFile, inputPath))
        );
      // Note: Restarting because an .elm file changed here won’t change the
      // fact that elm.json is missing. But it might feel clearer if the watcher
      // still reacts to the inputs rather than saying that they don’t affect
      // anything.
      case "ElmJsonNotFound":
        return error.elmJsonNotFound.some(
          (inputPath) => equalsInputPath(elmFile, inputPath)
        ) || error.foundElmJsonPaths.some(
          ({ inputPath }) => equalsInputPath(elmFile, inputPath)
        );
      // The only way I’ve found to trigger this is by a symlink loop.
      // However, that causes the watcher to error out and we have to exit so
      // this is never hit.
      /* v8 ignore start */
      case "InputsFailedToResolve":
        return error.inputsFailedToResolve.some(
          ({ inputPath }) => inputPath.theUncheckedInputPath === elmFile
        );
      /* v8 ignore stop */
      case "InputsNotFound":
        return error.inputsNotFound.some(
          (inputPath) => inputPath.theUncheckedInputPath === elmFile
        );
      // Changes to the .elm files don’t make the elm.json:s more unique, but
      // see  "ElmJsonNotFound" above for why we restart anyway.
      case "NonUniqueElmJsonPaths":
        return error.nonUniqueElmJsonPaths.some(
          ({ inputPath }) => equalsInputPath(elmFile, inputPath)
        );
    }
  });
}
function isElmJsonFileRelatedToElmJsonsErrors(absoluteElmJsonFilePath, elmJsonsErrors) {
  return elmJsonsErrors.some(({ error }) => {
    switch (error.tag) {
      case "DuplicateInputs":
      case "InputsFailedToResolve":
      case "InputsNotFound":
        return false;
      case "ElmJsonNotFound":
        return error.foundElmJsonPaths.some(
          ({ elmJsonPath }) => elmJsonPath === absoluteElmJsonFilePath
        );
      case "NonUniqueElmJsonPaths":
        return error.nonUniqueElmJsonPaths.some(
          ({ elmJsonPath }) => elmJsonPath === absoluteElmJsonFilePath
        );
    }
  });
}
function webSocketConnectionIsForOutputPath(webSocketConnection, outputPath) {
  switch (webSocketConnection.outputPath.tag) {
    case "OutputPathError":
      return false;
    case "OutputPath":
      return webSocketConnection.outputPath.theOutputPath === outputPath.theOutputPath;
  }
}
var WebSocketConnectedParams = Codec16.fields(
  {
    elmWatchVersion: Codec16.string,
    webSocketToken: Codec16.string,
    targetName: TargetName,
    elmCompiledTimestamp: Codec16.flatMap(Codec16.string, {
      decoder: (string9) => {
        const number5 = Number(string9);
        return Number.isFinite(number5) ? { tag: "Valid", value: number5 } : {
          tag: "DecoderError",
          error: {
            tag: "custom",
            message: "Expected a number",
            got: string9,
            path: []
          }
        };
      },
      encoder: (
        /* v8 ignore next */
        (value) => value.toString()
      )
    })
  },
  { allowExtraFields: false }
);
var WEBSOCKET_URL_EXPECTED_START = "/elm-watch?";
function parseWebSocketConnectRequestUrl(project, webSocketToken, urlString) {
  if (!urlString.startsWith(WEBSOCKET_URL_EXPECTED_START)) {
    return {
      tag: "BadUrl",
      expectedStart: WEBSOCKET_URL_EXPECTED_START,
      actualUrlString: urlString
    };
  }
  const params = new import_url.URLSearchParams(
    urlString.slice(WEBSOCKET_URL_EXPECTED_START.length)
  );
  const webSocketConnectedParamsResult = WebSocketConnectedParams.decoder(
    Object.fromEntries(params)
  );
  if (webSocketConnectedParamsResult.tag === "DecoderError") {
    return {
      tag: "ParamsDecodeError",
      error: webSocketConnectedParamsResult.error,
      actualUrlString: urlString
    };
  }
  const webSocketConnectedParams = webSocketConnectedParamsResult.value;
  const actualToken = Buffer.from(webSocketConnectedParams.webSocketToken);
  const expectedToken = Buffer.from(webSocketToken);
  const tokenIsCorrect = Buffer.byteLength(actualToken) === Buffer.byteLength(expectedToken) && crypto2.timingSafeEqual(actualToken, expectedToken);
  if (!tokenIsCorrect) {
    return { tag: "WrongToken" };
  }
  if (webSocketConnectedParams.elmWatchVersion !== "1.2.2") {
    return {
      tag: "WrongVersion",
      expectedVersion: "1.2.2",
      actualVersion: webSocketConnectedParams.elmWatchVersion
    };
  }
  const flatOutputs = getFlatOutputs(project);
  const { targetName } = webSocketConnectedParams;
  const matchElmJsonError = project.elmJsonsErrors.find(
    ({ outputPath }) => outputPath.targetName === targetName
  );
  const matchOutput = flatOutputs.find(
    ({ outputPath }) => outputPath.targetName === targetName
  );
  if (matchElmJsonError !== void 0) {
    return {
      tag: "ElmJsonError",
      error: matchElmJsonError
    };
  } else if (matchOutput !== void 0) {
    return {
      tag: "Success",
      elmJsonPath: matchOutput.elmJsonPath,
      outputPath: matchOutput.outputPath,
      outputState: matchOutput.outputState,
      elmCompiledTimestamp: webSocketConnectedParams.elmCompiledTimestamp
    };
  } else {
    const enabledOutputs = [
      ...project.elmJsonsErrors.map(({ outputPath }) => outputPath),
      ...flatOutputs.map(({ outputPath }) => outputPath)
    ];
    const disabledOutputs = Array.from(project.disabledOutputs);
    const disabledMatch = disabledOutputs.find(
      (outputPath) => outputPath.targetName === targetName
    );
    return disabledMatch === void 0 ? {
      tag: "TargetNotFound",
      targetName,
      enabledOutputs,
      disabledOutputs
    } : {
      tag: "TargetDisabled",
      targetName,
      enabledOutputs,
      disabledOutputs
    };
  }
}
function webSocketConnectRequestUrlResultToOutputPath(result) {
  switch (result.tag) {
    case "Success":
      return result.outputPath;
    case "ElmJsonError":
      return result.error.outputPath;
    default: {
      const _ = result;
      return { tag: "OutputPathError" };
    }
  }
}
function webSocketConnectRequestUrlErrorToString(error) {
  switch (error.tag) {
    case "BadUrl":
      return webSocketBadUrl(error.expectedStart, error.actualUrlString);
    case "ParamsDecodeError":
      return webSocketParamsDecodeError(
        error.error,
        error.actualUrlString
      );
    case "WrongToken":
      return webSocketWrongToken();
    case "WrongVersion":
      return webSocketWrongVersion(
        error.expectedVersion,
        error.actualVersion
      );
    case "TargetNotFound":
      return webSocketTargetNotFound(
        error.targetName,
        error.enabledOutputs,
        error.disabledOutputs
      );
    case "TargetDisabled":
      return webSocketTargetDisabled(
        error.targetName,
        error.enabledOutputs,
        error.disabledOutputs
      );
  }
}
function parseWebSocketToServerMessage(data) {
  const stringData = typeof data === "string" ? data : Array.isArray(data) ? Buffer.concat(data).toString("utf8") : data instanceof ArrayBuffer ? new TextDecoder("utf8").decode(data) : data.toString("utf8");
  const parsed = Codec16.JSON.parse(WebSocketToServerMessage, stringData);
  switch (parsed.tag) {
    case "DecoderError":
      return { tag: "DecoderError", error: parsed.error };
    case "Valid":
      return { tag: "Success", message: parsed.value };
  }
}
function onWebSocketConnected(date, model, elmWatchJsonPath, elmJsonPath, outputPath, outputState, elmCompiledTimestamp) {
  const event = {
    tag: "WebSocketConnectedNeedingCompilation",
    date,
    outputPath
  };
  const recompileNeeded = () => {
    const [newModel, cmds] = onWebSocketRecompileNeeded(
      model,
      outputPath,
      outputState
    );
    return [newModel, event, cmds];
  };
  switch (model.hotState.tag) {
    /* v8 ignore start */
    case "Restarting":
    case "Dependencies":
      return [model, event, []];
    /* v8 ignore stop */
    case "Idle":
    case "Compiling":
      switch (outputState.status.tag) {
        case "Success":
          return outputState.status.elmCompiledTimestamp === elmCompiledTimestamp ? [
            model,
            {
              tag: "WebSocketConnectedNeedingNoAction",
              date,
              outputPath
            },
            [
              {
                tag: "WebSocketSendToOutput",
                outputPath,
                message: {
                  tag: "StatusChanged",
                  status: {
                    tag: "AlreadyUpToDate",
                    compilationMode: outputState.compilationMode,
                    browserUiPosition: outputState.browserUiPosition
                  }
                }
              }
            ]
          ] : recompileNeeded();
        case "NotWrittenToDisk":
        case "ElmMakeTypecheckOnly":
          return recompileNeeded();
        /* v8 ignore next */
        case "ElmMake":
        case "Postprocess":
        case "Interrupted":
        case "QueuedForElmMake":
        case "QueuedForPostprocess":
          switch (model.hotState.tag) {
            /* v8 ignore start */
            case "Idle":
              return recompileNeeded();
            /* v8 ignore stop */
            case "Compiling":
              return [model, event, []];
          }
        default: {
          const _ = outputState.status;
          return [
            model,
            event,
            [
              {
                tag: "WebSocketSendCompileErrorToOutput",
                outputPath,
                compilationMode: outputState.compilationMode,
                browserUiPosition: outputState.browserUiPosition,
                openErrorOverlay: outputState.openErrorOverlay,
                errors: renderOutputErrors(
                  elmWatchJsonPath,
                  elmJsonPath,
                  outputPath,
                  outputState.status
                )
              }
            ]
          ];
        }
      }
  }
}
function onChangedCompilationModeOrBrowserUiPosition(model, outputPath, outputState) {
  switch (model.hotState.tag) {
    /* v8 ignore start */
    case "Restarting":
    case "Dependencies":
      return [model, []];
    /* v8 ignore stop */
    case "Idle":
    case "Compiling":
      return onWebSocketRecompileNeeded(model, outputPath, outputState);
  }
}
function onWebSocketRecompileNeeded(model, outputPath, outputState) {
  switch (model.nextAction.tag) {
    /* v8 ignore start */
    case "Restart":
      return [model, []];
    /* v8 ignore stop */
    case "Compile":
    case "NoAction":
      return [
        {
          ...model,
          nextAction: { tag: "Compile" }
        },
        [
          {
            tag: "MarkAsDirty",
            outputs: [{ outputPath, outputState }],
            killInstallDependencies: false
          }
        ]
      ];
  }
}
function compileNextAction(nextAction) {
  switch (nextAction.tag) {
    /* v8 ignore next */
    case "Restart":
    case "Compile":
      return nextAction;
    case "NoAction":
      return { tag: "Compile" };
  }
}
function onWebSocketToServerMessage(elmWatchJsonPath, model, date, output, webSocket, message) {
  switch (message.tag) {
    case "ChangedCompilationMode":
      switch (output.tag) {
        case "OutputPathError":
          return [model, []];
        case "Output": {
          const [newModel, cmds] = onChangedCompilationModeOrBrowserUiPosition(
            model,
            output.outputPath,
            output.outputState
          );
          return [
            {
              ...newModel,
              latestEvents: [
                ...newModel.latestEvents,
                {
                  tag: "WebSocketChangedCompilationMode",
                  date,
                  outputPath: output.outputPath,
                  compilationMode: message.compilationMode
                }
              ]
            },
            [
              {
                tag: "ChangeCompilationMode",
                outputState: output.outputState,
                compilationMode: message.compilationMode
              },
              ...cmds
            ]
          ];
        }
      }
    case "ChangedBrowserUiPosition":
      switch (output.tag) {
        case "OutputPathError":
          return [model, []];
        case "Output": {
          const [newModel, cmds] = onChangedCompilationModeOrBrowserUiPosition(
            model,
            output.outputPath,
            output.outputState
          );
          return [
            {
              ...newModel,
              latestEvents: [
                ...newModel.latestEvents,
                {
                  tag: "WebSocketChangedBrowserUiPosition",
                  date,
                  outputPath: output.outputPath,
                  browserUiPosition: message.browserUiPosition
                }
              ]
            },
            [
              {
                tag: "ChangeBrowserUiPosition",
                outputState: output.outputState,
                browserUiPosition: message.browserUiPosition
              },
              ...cmds
            ]
          ];
        }
      }
    case "ChangedOpenErrorOverlay":
      switch (output.tag) {
        case "OutputPathError":
          return [model, []];
        case "Output": {
          const errors = renderOutputErrors(
            elmWatchJsonPath,
            output.elmJsonPath,
            output.outputPath,
            output.outputState.status
          );
          return [
            model,
            [
              {
                tag: "ChangeOpenErrorOverlay",
                outputState: output.outputState,
                openErrorOverlay: message.openErrorOverlay
              },
              /* v8 ignore start */
              isNonEmptyArray(errors) ? {
                tag: "WebSocketSendCompileErrorToOutput",
                outputPath: output.outputPath,
                compilationMode: output.outputState.compilationMode,
                browserUiPosition: output.outputState.browserUiPosition,
                openErrorOverlay: message.openErrorOverlay,
                errors
              } : { tag: "NoCmd" }
              /* v8 ignore stop */
            ]
          ];
        }
      }
    case "FocusedTab":
      return [
        model,
        [
          { tag: "WebSocketUpdatePriority", webSocket },
          {
            tag: "WebSocketSend",
            webSocket,
            message: { tag: "FocusedTabAcknowledged" }
          }
        ]
      ];
    case "PressedOpenEditor":
      return [
        model,
        [
          {
            tag: "OpenEditor",
            file: message.file,
            line: message.line,
            column: message.column,
            webSocket
          }
        ]
      ];
  }
}
function webSocketSend(webSocket, message) {
  webSocket.send(encodeWebSocketToClientMessage(message));
}
function webSocketSendToOutput(outputPath, message, webSocketConnections) {
  for (const webSocketConnection of webSocketConnections) {
    if (webSocketConnectionIsForOutputPath(webSocketConnection, outputPath)) {
      webSocketSend(webSocketConnection.webSocket, message);
    }
  }
}
function getNextActionSleepMs(events) {
  return Math.max(0, ...events.map(getLatestEventSleepMs));
}
function getLatestEventSleepMs(event) {
  switch (event.tag) {
    // Sleep for a little bit to avoid unnecessary recompilation when using
    // “save all” in an editor, or when running `git switch some-branch` or `git
    // restore .`. These operations results in many files being
    // added/changed/deleted, usually with 0-1 ms between each event.
    case "WatcherEvent":
      return 10;
    // Also sleep for a little bit when web sockets connect and disconnect.
    // That’s useful when there are burst connections because of multiple
    // scripts on the same page, or many tabs with elm-watch. This is slower
    // than file system events.
    case "WebSocketClosed":
    case "WebSocketConnectedNeedingCompilation":
    case "WebSocketConnectedNeedingNoAction":
    case "WebSocketConnectedWithErrors":
    case "WorkersLimitedAfterWebSocketClosed":
      return 100;
    // When switching compilation mode or browser UI position, sleep a short
    // amount of time so that the change feels more immediate.
    case "WebSocketChangedBrowserUiPosition":
    case "WebSocketChangedCompilationMode":
      return 10;
  }
}
function filterLatestEvents(events) {
  const filtered = events.filter(
    (event) => !(event.tag === "WatcherEvent" && !event.affectsAnyTarget)
  );
  return isNonEmptyArray(filtered) ? filtered : events;
}
function infoMessageWithTimeline({
  loggerConfig,
  date,
  mutable,
  message,
  events,
  hasErrors
}) {
  return [
    "",
    // Empty line separator.
    printStats(loggerConfig, mutable),
    "",
    printTimeline(loggerConfig, events),
    printMessageWithTimeAndEmoji({
      loggerConfig,
      emojiName: hasErrors ? "Error" : "Success",
      date,
      dateHighlight: bold,
      message
    })
  ].flatMap((part) => part ?? []).join("\n");
}
function printMessageWithTimeAndEmoji({
  loggerConfig,
  emojiName,
  date,
  dateHighlight: highlightTime,
  message
}) {
  const newDate = loggerConfig.mockedTimings ? /* @__PURE__ */ new Date("2022-02-05T13:10:05Z") : date;
  return printStatusLine({
    maxWidth: Infinity,
    fancy: loggerConfig.fancy,
    isTTY: loggerConfig.isTTY,
    emojiName,
    string: `${highlightTime(formatTime(newDate))} ${message}`
  });
}
function printStats(loggerConfig, mutable) {
  const numWorkers = mutable.postprocessWorkerPool.getSize();
  return [
    numWorkers > 0 ? `${dim(`${ELM_WATCH_NODE} workers:`)} ${numWorkers}` : void 0,
    `${dim("web socket connections:")} ${mutable.webSocketConnections.length} ${dim(`(ws://0.0.0.0:${mutable.webSocketServer.port})`)}`
  ].flatMap(
    (part) => part === void 0 ? [] : printStatusLine({
      maxWidth: Infinity,
      fancy: loggerConfig.fancy,
      isTTY: loggerConfig.isTTY,
      emojiName: "Stats",
      string: part
    })
  ).join("\n");
}
function printTimeline(loggerConfig, events) {
  if (!isNonEmptyArray(events)) {
    return void 0;
  }
  const base = 2;
  if (events.length <= 2 * base + 1) {
    return mapNonEmptyArray(
      events,
      (event) => printEvent(loggerConfig, event)
    ).join("\n");
  }
  const start = events.slice(0, base);
  const end = events.slice(-base);
  const numMoreEvents = events.length - 2 * base;
  return [
    ...start.map((event) => printEvent(loggerConfig, event)),
    `${loggerConfig.fancy ? "   " : ""}(${numMoreEvents} more events)`,
    ...end.map((event) => printEvent(loggerConfig, event))
  ].join("\n");
}
function printEvent(loggerConfig, event) {
  return printMessageWithTimeAndEmoji({
    loggerConfig,
    emojiName: "Information",
    date: event.date,
    dateHighlight: dim,
    message: dim(printEventMessage(event))
  });
}
function printEventMessage(event) {
  switch (event.tag) {
    case "WatcherEvent":
      return `${capitalize(event.eventName)} ${event.file}`;
    case "WebSocketClosed":
      return `Web socket disconnected for: ${event.outputPath.tag === "OutputPath" ? event.outputPath.targetName : "(no matching target)"}`;
    case "WebSocketConnectedNeedingCompilation":
      return `Web socket connected needing compilation of: ${event.outputPath.targetName}`;
    case "WebSocketConnectedNeedingNoAction":
      return `Web socket connected for: ${event.outputPath.targetName}`;
    case "WebSocketConnectedWithErrors":
      return `Web socket connected with errors (see the browser for details)`;
    case "WebSocketChangedBrowserUiPosition":
      return `Changed browser UI position to ${quote(
        event.browserUiPosition
      )} of: ${event.outputPath.targetName}`;
    case "WebSocketChangedCompilationMode":
      return `Changed compilation mode to ${quote(event.compilationMode)} of: ${event.outputPath.targetName}`;
    case "WorkersLimitedAfterWebSocketClosed":
      return `Terminated ${event.numTerminatedWorkers} superfluous ${/* v8 ignore next */
      event.numTerminatedWorkers === 1 ? "worker" : "workers"}`;
  }
}
function compileFinishedMessage(loggerConfig, duration) {
  return `Compilation finished in ${bold(
    printDurationMs(
      loggerConfig.mockedTimings ? 123 : (
        /* v8 ignore next */
        duration
      )
    ).trim()
  )}.`;
}
function printEventsMessage(events, disabledOutputs) {
  const what1 = events.length === 1 ? "file is" : "files are";
  const what2 = disabledOutputs.length > 0 ? "any of the enabled targets" : "any target";
  return events.every(
    (event) => event.tag === "WatcherEvent" && !event.affectsAnyTarget
  ) ? `FYI: The above Elm ${what1} not imported by ${what2}. Nothing to do!` : "Everything up to date.";
}

// src/Make.ts
async function run2(env, logger, getNow, project, postprocessWorkerPool) {
  const startTimestamp = getNow().getTime();
  const installResult = await installDependencies(
    env,
    logger,
    getNow,
    project
  ).promise;
  switch (installResult.tag) {
    case "Error":
    case "Killed":
      await postprocessWorkerPool.terminate();
      return { tag: "Error" };
    case "Success":
      break;
  }
  const initialOutputActions = getOutputActions({
    project,
    runMode: "make",
    includeInterrupted: true,
    prioritizedOutputs: "AllEqualPriority"
  });
  printStatusLinesForElmJsonsErrors(logger, project);
  if (isNonEmptyArray(initialOutputActions.actions) && !isNonEmptyArray(project.elmJsonsErrors)) {
    printSpaceForOutputs(logger, "make", initialOutputActions);
    await new Promise((resolve3, reject) => {
      const cycle = (outputActions) => {
        for (const action of outputActions.actions) {
          handleOutputAction({
            env,
            logger,
            getNow,
            runMode: { tag: "make" },
            elmWatchJsonPath: project.elmWatchJsonPath,
            total: outputActions.total,
            action,
            postprocess: project.postprocess,
            postprocessWorkerPool
          }).then(() => {
            const nextOutputActions = getNextOutputActions(project);
            if (isNonEmptyArray(nextOutputActions.actions)) {
              cycle(nextOutputActions);
            } else if (nextOutputActions.numExecuting === 0) {
              resolve3();
            }
          }).catch(reject);
        }
      };
      cycle(initialOutputActions);
    });
  }
  const numWorkers = postprocessWorkerPool.getSize();
  await postprocessWorkerPool.terminate();
  const errors = extractErrors(project);
  const failed = isNonEmptyArray(errors);
  if (failed) {
    printErrors(logger, errors);
  }
  const duration = getNow().getTime() - startTimestamp;
  logger.write("");
  logger.write(
    compileFinishedMessage2({
      loggerConfig: logger.config,
      duration,
      numWorkers,
      hasErrors: failed
    })
  );
  return failed ? { tag: "Error" } : { tag: "Success" };
}
function getNextOutputActions(project) {
  const nextOutputActions = getOutputActions({
    project,
    runMode: "make",
    includeInterrupted: true,
    prioritizedOutputs: "AllEqualPriority"
  });
  return nextOutputActions.numErrors > 0 ? {
    ...nextOutputActions,
    actions: nextOutputActions.actions.filter(
      (action2) => action2.tag !== "NeedsPostprocess"
    )
  } : nextOutputActions;
}
function compileFinishedMessage2({
  loggerConfig,
  duration,
  numWorkers,
  hasErrors
}) {
  const workersString = numWorkers > 0 ? dim(
    ` (using ${numWorkers} ${ELM_WATCH_NODE} ${numWorkers === 1 ? "worker" : "workers"}).`
  ) : ".";
  return printStatusLine({
    maxWidth: Infinity,
    fancy: loggerConfig.fancy,
    isTTY: loggerConfig.isTTY,
    emojiName: hasErrors ? "Error" : "Success",
    string: `Compilation finished in ${bold(
      printDurationMs(
        loggerConfig.mockedTimings ? 123 : (
          /* v8 ignore next */
          duration
        )
      ).trim()
    )}${workersString}`
  });
}

// src/Run.ts
async function run3(cwd, env, logger, getNow, runMode, args, restartReasons, postprocessWorkerPool, webSocketState, hotKillManager) {
  const parseResult = findReadAndParse(cwd);
  switch (parseResult.tag) {
    case "ReadError":
      logger.errorTemplate(
        readElmWatchJson(
          parseResult.elmWatchJsonPath,
          parseResult.error
        )
      );
      return handleElmWatchJsonError(
        logger,
        getNow,
        runMode,
        parseResult.elmWatchJsonPath,
        postprocessWorkerPool
      );
    case "DecoderError":
      logger.errorTemplate(
        decodeElmWatchJson(
          parseResult.elmWatchJsonPath,
          parseResult.error
        )
      );
      return handleElmWatchJsonError(
        logger,
        getNow,
        runMode,
        parseResult.elmWatchJsonPath,
        postprocessWorkerPool
      );
    case "ElmWatchJsonNotFound":
      logger.errorTemplate(elmWatchJsonNotFound(cwd, args));
      return { tag: "Exit", exitCode: 1 };
    case "Parsed": {
      const parseArgsResult = parseArgs(runMode, args);
      switch (parseArgsResult.tag) {
        case "UnknownFlags":
          logger.errorTemplate(
            unknownFlags(
              cwd,
              parseResult.elmWatchJsonPath,
              runMode,
              args,
              parseArgsResult.unknownFlags
            )
          );
          return { tag: "Exit", exitCode: 1 };
        case "DebugOptimizeForHot":
          logger.errorTemplate(debugOptimizeForHot());
          return { tag: "Exit", exitCode: 1 };
        case "DebugOptimizeClash":
          logger.errorTemplate(debugOptimizeClash());
          return { tag: "Exit", exitCode: 1 };
        case "Success": {
          const { config } = parseResult;
          const knownTargets = Object.keys(
            config.targets
          );
          const unknownTargetsSubstrings2 = parseArgsResult.targetsSubstrings.filter(
            (substring) => !knownTargets.some(
              (targetName) => targetName.includes(substring)
            )
          );
          if (isNonEmptyArray(unknownTargetsSubstrings2)) {
            logger.errorTemplate(
              unknownTargetsSubstrings(
                parseResult.elmWatchJsonPath,
                knownTargets,
                unknownTargetsSubstrings2
              )
            );
            return { tag: "Exit", exitCode: 1 };
          }
          const elmWatchStuffDir = markAsElmWatchStuffDir(
            absolutePathFromString(
              absoluteDirname(parseResult.elmWatchJsonPath),
              "elm-stuff",
              "elm-watch"
            )
          );
          const elmWatchStuffJsonPath = markAsElmWatchStuffJsonPath(
            absolutePathFromString(elmWatchStuffDir, "stuff.json")
          );
          const elmWatchStuffJsonParseResult = runMode === "hot" ? readAndParse(elmWatchStuffJsonPath) : void 0;
          switch (elmWatchStuffJsonParseResult?.tag) {
            case "ElmWatchStuffJsonReadError":
              logger.errorTemplate(
                readElmWatchStuffJson(
                  elmWatchStuffJsonPath,
                  elmWatchStuffJsonParseResult.errors
                )
              );
              return { tag: "Exit", exitCode: 1 };
            case "ElmWatchStuffJsonDecodeError":
              logger.errorTemplate(
                decodeElmWatchStuffJson(
                  elmWatchStuffJsonPath,
                  elmWatchStuffJsonParseResult.error
                )
              );
              return { tag: "Exit", exitCode: 1 };
            case void 0:
            case "Parsed":
            case "NoElmWatchStuffJson": {
              const elmWatchStuffJson2 = elmWatchStuffJsonParseResult?.tag === "Parsed" ? elmWatchStuffJsonParseResult.elmWatchStuffJson : void 0;
              const initProjectResult = initProject({
                env,
                getNow,
                compilationMode: parseArgsResult.compilationMode,
                elmWatchJsonPath: parseResult.elmWatchJsonPath,
                config: parseResult.config,
                enabledTargetsSubstrings: isNonEmptyArray(
                  parseArgsResult.targetsSubstrings
                ) ? parseArgsResult.targetsSubstrings : knownTargets,
                elmWatchStuffDir,
                elmWatchStuffJsonPath,
                elmWatchStuffJson: elmWatchStuffJson2
              });
              switch (initProjectResult.tag) {
                case "DuplicateOutputs":
                  logger.errorTemplate(
                    duplicateOutputs(
                      parseResult.elmWatchJsonPath,
                      initProjectResult.duplicates
                    )
                  );
                  return handleElmWatchJsonError(
                    logger,
                    getNow,
                    runMode,
                    parseResult.elmWatchJsonPath,
                    postprocessWorkerPool
                  );
                case "Project": {
                  const { project } = initProjectResult;
                  logger.debug("Project", projectToDebug(project));
                  switch (project.postprocess.tag) {
                    case "NoPostprocess":
                      break;
                    case "Postprocess":
                      if (project.postprocess.postprocessArray[0] === ELM_WATCH_NODE) {
                        postprocessWorkerPool.getOrCreateAvailableWorker();
                      }
                      break;
                  }
                  switch (runMode) {
                    case "make": {
                      const result = await run2(
                        env,
                        logger,
                        getNow,
                        project,
                        postprocessWorkerPool
                      );
                      switch (result.tag) {
                        case "Error":
                          return { tag: "Exit", exitCode: 1 };
                        case "Success":
                          return { tag: "Exit", exitCode: 0 };
                      }
                    }
                    case "hot": {
                      const result = await run(
                        env,
                        logger,
                        getNow,
                        restartReasons,
                        postprocessWorkerPool,
                        webSocketState,
                        elmWatchStuffJson2?.webSocketToken ?? markAsWebSocketToken(crypto3.randomUUID()),
                        project,
                        config.port !== void 0 ? { tag: "PortFromConfig", port: config.port } : elmWatchStuffJson2 !== void 0 ? {
                          tag: "PersistedPort",
                          port: elmWatchStuffJson2.port
                        } : { tag: "NoPort" },
                        hotKillManager
                      );
                      switch (result.tag) {
                        case "ExitOnHandledFatalError":
                          logger.errorTemplate(result.errorTemplate);
                          return { tag: "Exit", exitCode: 1 };
                        case "ExitOnIdle":
                          return {
                            tag: "Exit",
                            exitCode: result.reason === "CtrlCPressedOrStdinEnd" ? 0 : 1
                          };
                        case "Restart":
                          return result;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
async function handleElmWatchJsonError(logger, getNow, runMode, elmWatchJsonPath, postprocessWorkerPool) {
  switch (runMode) {
    case "make":
      return { tag: "Exit", exitCode: 1 };
    case "hot": {
      logger.write("");
      printNumErrors(logger, 1);
      const elmWatchJsonEvent = await watchElmWatchJsonOnce(
        getNow,
        elmWatchJsonPath
      );
      logger.clearScreen();
      return {
        tag: "Restart",
        restartReasons: [{ ...elmWatchJsonEvent, affectsAnyTarget: true }],
        postprocessWorkerPool,
        webSocketState: void 0
      };
    }
  }
}

// src/index.ts
async function elmWatchCli(args, {
  cwd: cwdString,
  env,
  stdin,
  stdout,
  stderr,
  logDebug,
  hotKillManager = { kill: void 0 }
}) {
  const getNow = () => /* @__PURE__ */ new Date();
  const logger = makeLogger({
    env,
    getNow,
    stdin,
    stdout,
    stderr,
    logDebug
  });
  const cwd = markAsCwd(
    absolutePathFromString(markAsAbsolutePath(process.cwd()), cwdString)
  );
  const isHelp = args.some(
    (arg) => arg === "-h" || arg === "-help" || arg === "--help"
  );
  if (isHelp) {
    logger.write(render(logger.config));
    return 0;
  }
  const restArgs = args.slice(1).map(markAsCliArg);
  switch (args[0]) {
    case void 0:
    case "help":
      logger.write(render(logger.config));
      return 0;
    case "init":
      return init(cwd, logger, restArgs);
    case "make":
    case "hot": {
      const runMode = args[0];
      return new Promise((resolve3, reject) => {
        const doIt = async () => {
          let result;
          do {
            result = await run3(
              cwd,
              env,
              logger,
              getNow,
              runMode,
              restArgs,
              result === void 0 ? [] : result.restartReasons,
              result === void 0 ? new PostprocessWorkerPool(reject) : result.postprocessWorkerPool,
              result === void 0 ? void 0 : result.webSocketState,
              hotKillManager
            );
          } while (result.tag === "Restart");
          switch (result.tag) {
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            case "Exit":
              return result.exitCode;
          }
        };
        doIt().then(resolve3).catch(reject);
      });
    }
    default:
      logger.write(`Unknown command: ${args[0]}`);
      return 1;
  }
}
if (require.main === module) {
  process.title = "elm-watch";
  elmWatchCli(process.argv.slice(2), {
    cwd: process.cwd(),
    env: process.env,
    stdin: process.stdin,
    stdout: process.stdout,
    stderr: process.stderr,
    logDebug: (message) => process.stderr.write(`${message}
`)
  }).then((exitCode) => {
    process.exitCode = exitCode;
    if (process.stdin.setRawMode !== void 0) {
      process.stdin.setRawMode(false);
    }
    if (process.stdout.isTTY) {
      process.stdout.write(
        "Exiting elm-watch. Press ctrl+c (again) to force."
      );
      process.once("exit", () => {
        process.stdout.cursorTo(0);
        process.stdout.clearLine(0);
      });
    }
  }).catch((error) => {
    process.stderr.write(
      `Unexpected error:
${unknownErrorToString(error)}
`
    );
    process.exit(1);
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  elmWatchCli
});