export type Codec<Decoded, Encoded = unknown> = {
    decoder: (value: unknown) => DecoderResult<Decoded>;
    encoder: (value: Decoded) => Encoded;
};
export type DecoderResult<Decoded> = {
    tag: "DecoderError";
    error: DecoderError;
} | {
    tag: "Valid";
    value: Decoded;
};
export type Infer<T extends Codec<any>> = Extract<ReturnType<T["decoder"]>, {
    tag: "Valid";
}>["value"];
export type InferEncoded<T extends Codec<any>> = ReturnType<T["encoder"]>;
type Expand<T> = T extends infer O ? {
    [K in keyof O]: O[K];
} : never;
declare const CodecJSON: {
    parse<Decoded>(codec: Codec<Decoded, unknown>, jsonString: string): DecoderResult<Decoded>;
    stringify<Decoded_1, Encoded>(codec: Codec<Decoded_1, Encoded>, value: Decoded_1, space?: number | string): string;
};
export { CodecJSON as JSON };
export declare const unknown: Codec<unknown>;
export declare const boolean: Codec<boolean, boolean>;
export declare const number: Codec<number, number>;
export declare const bigint: Codec<bigint, bigint>;
export declare const string: Codec<string, string>;
type primitive = bigint | boolean | number | string | symbol | null | undefined;
export declare function primitiveUnion<const Variants extends readonly [primitive, ...Array<primitive>]>(variants: Variants): Codec<Variants[number], Variants[number]>;
export declare function array<DecodedItem, EncodedItem>(codec: Codec<DecodedItem, EncodedItem>): Codec<Array<DecodedItem>, Array<EncodedItem>>;
export declare function record<DecodedValue, EncodedValue>(codec: Codec<DecodedValue, EncodedValue>): Codec<Record<string, DecodedValue>, Record<string, EncodedValue>>;
type Field<Decoded, Encoded, Meta extends FieldMeta> = Meta & {
    codec: Codec<Decoded, Encoded>;
};
type FieldMeta = {
    renameFrom?: string | undefined;
    optional?: boolean | undefined;
    tag?: {
        decoded: primitive;
        encoded: primitive;
    } | undefined;
};
type FieldsMapping = Record<string, Codec<any> | Field<any, any, FieldMeta>>;
type InferField<T extends Codec<any> | Field<any, any, FieldMeta>> = T extends Field<any, any, FieldMeta> ? Infer<T["codec"]> : T extends Codec<any> ? Infer<T> : never;
type InferEncodedField<T extends Codec<any> | Field<any, any, FieldMeta>> = T extends Field<any, any, FieldMeta> ? InferEncoded<T["codec"]> : T extends Codec<any> ? InferEncoded<T> : never;
type InferFields<Mapping extends FieldsMapping> = Expand<{
    [Key in keyof Mapping as Mapping[Key] extends {
        optional: true;
    } ? never : Key]: InferField<Mapping[Key]>;
} & {
    [Key in keyof Mapping as Mapping[Key] extends {
        optional: true;
    } ? Key : never]?: InferField<Mapping[Key]>;
}>;
type InferEncodedFields<Mapping extends FieldsMapping> = Expand<{
    [Key in keyof Mapping as Mapping[Key] extends {
        optional: true;
    } ? never : Mapping[Key] extends {
        renameFrom: infer Name;
    } ? Name extends string ? Name : Key : Key]: InferEncodedField<Mapping[Key]>;
} & {
    [Key in keyof Mapping as Mapping[Key] extends {
        optional: true;
    } ? Mapping[Key] extends {
        renameFrom: infer Name;
    } ? Name extends string ? Name : Key : Key : never]?: InferEncodedField<Mapping[Key]>;
}>;
export declare function fields<Mapping extends FieldsMapping>(mapping: Mapping, { allowExtraFields }?: {
    allowExtraFields?: boolean;
}): Codec<InferFields<Mapping>, InferEncodedFields<Mapping>>;
export declare function field<Decoded, Encoded, const Meta extends Omit<FieldMeta, "tag">>(codec: Codec<Decoded, Encoded>, meta: Meta): Field<Decoded, Encoded, Meta>;
type InferFieldsUnion<MappingsUnion extends FieldsMapping> = MappingsUnion extends any ? InferFields<MappingsUnion> : never;
type InferEncodedFieldsUnion<MappingsUnion extends FieldsMapping> = MappingsUnion extends any ? InferEncodedFields<MappingsUnion> : never;
type Variant<DecodedCommonField extends number | string | symbol> = Record<DecodedCommonField, Field<any, any, {
    tag: {
        decoded: primitive;
        encoded: primitive;
    };
}>> & Record<string, Codec<any> | Field<any, any, FieldMeta>>;
export declare function taggedUnion<const DecodedCommonField extends keyof Variants[number], Variants extends readonly [
    Variant<DecodedCommonField>,
    ...Array<Variant<DecodedCommonField>>
]>(decodedCommonField: keyof InferEncodedFieldsUnion<Variants[number]> extends never ? [
    "taggedUnion variants must have a field in common, and their encoded field names must be the same",
    never
] : DecodedCommonField, variants: Variants, { allowExtraFields }?: {
    allowExtraFields?: boolean;
}): Codec<InferFieldsUnion<Variants[number]>, InferEncodedFieldsUnion<Variants[number]>>;
export declare function tag<const Decoded extends primitive>(decoded: Decoded): Field<Decoded, Decoded, {
    tag: {
        decoded: primitive;
        encoded: primitive;
    };
}>;
export declare function tag<const Decoded extends primitive, const Encoded extends primitive>(decoded: Decoded, options: {
    renameTagFrom: Encoded;
}): Field<Decoded, Encoded, {
    tag: {
        decoded: primitive;
        encoded: primitive;
    };
}>;
export declare function tag<const Decoded extends primitive, const EncodedFieldName extends string>(decoded: Decoded, options: {
    renameFieldFrom: EncodedFieldName;
}): Field<Decoded, Decoded, {
    renameFrom: EncodedFieldName;
    tag: {
        decoded: primitive;
        encoded: primitive;
    };
}>;
export declare function tag<const Decoded extends primitive, const Encoded extends primitive, const EncodedFieldName extends string>(decoded: Decoded, options: {
    renameTagFrom: Encoded;
    renameFieldFrom: EncodedFieldName;
}): Field<Decoded, Encoded, {
    renameFrom: EncodedFieldName;
    tag: {
        decoded: primitive;
        encoded: primitive;
    };
}>;
type InferTuple<Codecs extends ReadonlyArray<Codec<any>>> = [
    ...{
        [P in keyof Codecs]: Infer<Codecs[P]>;
    }
];
type InferEncodedTuple<Codecs extends ReadonlyArray<Codec<any>>> = [
    ...{
        [P in keyof Codecs]: InferEncoded<Codecs[P]>;
    }
];
export declare function tuple<const Codecs extends ReadonlyArray<Codec<any>>>(codecs: Codecs): Codec<InferTuple<Codecs>, InferEncodedTuple<Codecs>>;
type Multi<Types> = Types extends any ? Types extends "undefined" ? {
    type: "undefined";
    value: undefined;
} : Types extends "null" ? {
    type: "null";
    value: null;
} : Types extends "boolean" ? {
    type: "boolean";
    value: boolean;
} : Types extends "number" ? {
    type: "number";
    value: number;
} : Types extends "bigint" ? {
    type: "bigint";
    value: bigint;
} : Types extends "string" ? {
    type: "string";
    value: string;
} : Types extends "symbol" ? {
    type: "symbol";
    value: symbol;
} : Types extends "function" ? {
    type: "function";
    value: Function;
} : Types extends "array" ? {
    type: "array";
    value: Array<unknown>;
} : Types extends "object" ? {
    type: "object";
    value: Record<string, unknown>;
} : never : never;
type MultiTypeName = "array" | "bigint" | "boolean" | "function" | "null" | "number" | "object" | "string" | "symbol" | "undefined";
export declare function multi<Types extends readonly [MultiTypeName, ...Array<MultiTypeName>]>(types: Types): Codec<Multi<Types[number]>, Multi<Types[number]>["value"]>;
export declare function recursive<Decoded, Encoded>(callback: () => Codec<Decoded, Encoded>): Codec<Decoded, Encoded>;
export declare function undefinedOr<Decoded, Encoded>(codec: Codec<Decoded, Encoded>): Codec<Decoded | undefined, Encoded | undefined>;
export declare function nullOr<Decoded, Encoded>(codec: Codec<Decoded, Encoded>): Codec<Decoded | null, Encoded | null>;
export declare function map<const Decoded, Encoded, NewDecoded>(codec: Codec<Decoded, Encoded>, transform: {
    decoder: (value: Decoded) => NewDecoded;
    encoder: (value: NewDecoded) => Readonly<Decoded>;
}): Codec<NewDecoded, Encoded>;
export declare function flatMap<const Decoded, Encoded, NewDecoded>(codec: Codec<Decoded, Encoded>, transform: {
    decoder: (value: Decoded) => DecoderResult<NewDecoded>;
    encoder: (value: NewDecoded) => Readonly<Decoded>;
}): Codec<NewDecoded, Encoded>;
export type DecoderError = {
    path: Array<number | string>;
    orExpected?: "null or undefined" | "null" | "undefined";
} & ({
    tag: "custom";
    message: string;
    got?: unknown;
} | {
    tag: "exact fields";
    knownFields: Array<string>;
    got: Array<string>;
} | {
    tag: "missing field";
    field: string;
    got: Record<string, unknown>;
} | {
    tag: "tuple size";
    expected: number;
    got: number;
} | {
    tag: "unknown multi type";
    knownTypes: Array<"array" | "boolean" | "null" | "number" | "object" | "string" | "undefined">;
    got: unknown;
} | {
    tag: "unknown primitiveUnion variant";
    knownVariants: Array<primitive>;
    got: unknown;
} | {
    tag: "unknown taggedUnion tag";
    knownTags: Array<primitive>;
    got: unknown;
} | {
    tag: "wrong tag";
    expected: primitive;
    got: unknown;
} | {
    tag: "array";
    got: unknown;
} | {
    tag: "bigint";
    got: unknown;
} | {
    tag: "boolean";
    got: unknown;
} | {
    tag: "number";
    got: unknown;
} | {
    tag: "object";
    got: unknown;
} | {
    tag: "string";
    got: unknown;
});
export declare function format(error: DecoderError, options?: ReprOptions): string;
export type ReprOptions = {
    depth?: number | undefined;
    indent?: string | undefined;
    maxArrayChildren?: number | undefined;
    maxObjectChildren?: number | undefined;
    maxLength?: number | undefined;
    sensitive?: boolean | undefined;
};
export declare function repr(value: unknown, { depth, indent, maxArrayChildren, maxObjectChildren, maxLength, sensitive, }?: ReprOptions): string;
